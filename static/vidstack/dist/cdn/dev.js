import { CaptionsRenderer, renderVTTCueString, updateTimedVTTCueNodes } from './chunks/chunk-WAU2KHFR.js';
import './chunks/chunk-V3ZV3QM2.js';
import { preconnect, SET_AUTO_QUALITY, ENABLE_AUTO_QUALITY, coerceToError } from './chunks/chunk-J2DNBBS3.js';
import { isTrackCaptionKind, TEXT_TRACK_CAN_LOAD, TextTrack, ATTACH_VIDEO, TEXT_TRACK_NATIVE_HLS, TEXT_TRACK_ON_MODE_CHANGE, TEXT_TRACK_UPDATE_ACTIVE_CUES, TEXT_TRACK_NATIVE } from './chunks/chunk-TA667RH3.js';
import { canOrientScreen, isHLSSupported, round, LIST_ON_USER_SELECT, LIST_ON_RESET, LIST_ADD, LIST_REMOVE, clampNumber, LIST_RESET, getNumberOfDecimalPlaces, IS_SAFARI, LIST_READONLY, LIST_ON_REMOVE, LIST_SET_READONLY, LIST_SELECT, AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, isHLSSrc, canPlayHLSNatively, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES } from './chunks/chunk-XUPMJMXW.js';
import './chunks/chunk-YWTIFSNT.js';
import './chunks/chunk-ZNBZMUQ5.js';
import './chunks/chunk-LZ7TD6FM.js';
import { volume_high_default } from './chunks/chunk-TIF6ZKKL.js';
import { volume_low_default } from './chunks/chunk-VS7B7I6T.js';
import './chunks/chunk-XI2OIH2K.js';
import './chunks/chunk-YOLHXCNI.js';
import './chunks/chunk-UMPGLVMI.js';
import './chunks/chunk-IOY5NX3Y.js';
import './chunks/chunk-D4U6AHQK.js';
import './chunks/chunk-SYM6F5TT.js';
import './chunks/chunk-H7QWX5K4.js';
import './chunks/chunk-2V2YIOEG.js';
import './chunks/chunk-PQCMQX4D.js';
import './chunks/chunk-GY57YNO7.js';
import './chunks/chunk-JUNJK27N.js';
import './chunks/chunk-LEZVP3RN.js';
import './chunks/chunk-BH7KMW6L.js';
import './chunks/chunk-DJGIIXAH.js';
import './chunks/chunk-DOGUV2BG.js';
import './chunks/chunk-WM4U3YMS.js';
import './chunks/chunk-R5EUOQAA.js';
import './chunks/chunk-M6UOSRY5.js';
import './chunks/chunk-W3Q5SX3S.js';
import './chunks/chunk-HBKEXKVL.js';
import './chunks/chunk-NSUGCUFT.js';
import './chunks/chunk-ISSCWZBX.js';
import { seek_backward_default } from './chunks/chunk-ITBJH7Z3.js';
import './chunks/chunk-AQTMPRYR.js';
import './chunks/chunk-LT2SRWUV.js';
import './chunks/chunk-ODSOBE5F.js';
import { seek_forward_default } from './chunks/chunk-ZZQFCRSQ.js';
import './chunks/chunk-RKCTSPQ2.js';
import './chunks/chunk-Z3K26RJX.js';
import './chunks/chunk-LYW3UZUX.js';
import './chunks/chunk-OYUHAI22.js';
import './chunks/chunk-UVNJWJ2T.js';
import { replay_default } from './chunks/chunk-UPKFI4JX.js';
import './chunks/chunk-HNSDDFDE.js';
import './chunks/chunk-JMSDJCPT.js';
import { picture_in_picture_default } from './chunks/chunk-5LKL4CQE.js';
import { play_default } from './chunks/chunk-X7QHDM2U.js';
import './chunks/chunk-UMVCXCLG.js';
import './chunks/chunk-NI77VNJJ.js';
import './chunks/chunk-2QN3ZZMR.js';
import './chunks/chunk-CHBVUFLW.js';
import './chunks/chunk-M23AMFBA.js';
import './chunks/chunk-XTQCJXSF.js';
import './chunks/chunk-FAUZQNIF.js';
import './chunks/chunk-PEARMCQA.js';
import { mute_default } from './chunks/chunk-QCAIKWCZ.js';
import './chunks/chunk-GEDM6VLI.js';
import './chunks/chunk-HA7DBBEV.js';
import './chunks/chunk-QYMNDV24.js';
import { pause_default } from './chunks/chunk-7SHPP3R2.js';
import { picture_in_picture_exit_default } from './chunks/chunk-B3FX5S45.js';
import './chunks/chunk-776SRTNZ.js';
import './chunks/chunk-P3F76SXL.js';
import './chunks/chunk-M2XEKXSU.js';
import './chunks/chunk-TNZVCC5E.js';
import './chunks/chunk-A6U25GS2.js';
import './chunks/chunk-TFCSIH4W.js';
import './chunks/chunk-6LDT4TIP.js';
import './chunks/chunk-GOUJS63S.js';
import './chunks/chunk-QBJ2BIVX.js';
import './chunks/chunk-JEOIRZPL.js';
import './chunks/chunk-7OROS5TQ.js';
import { fullscreen_exit_default } from './chunks/chunk-QFB3EKU6.js';
import { fullscreen_default } from './chunks/chunk-NRWDIVYW.js';
import './chunks/chunk-CLY3YWNF.js';
import './chunks/chunk-EG2HUQNX.js';
import './chunks/chunk-NXYMJLO4.js';
import './chunks/chunk-ZIY4YSTG.js';
import './chunks/chunk-OQJEIR2A.js';
import './chunks/chunk-7PITQZ42.js';
import './chunks/chunk-UCEACRWB.js';
import './chunks/chunk-ES2ZK6OQ.js';
import './chunks/chunk-WKBM7FOK.js';
import './chunks/chunk-ZYQYU5V2.js';
import './chunks/chunk-LEQ6LZW6.js';
import './chunks/chunk-EKHVWHTK.js';
import './chunks/chunk-KIN3IAUT.js';
import './chunks/chunk-SD2KBNJU.js';
import './chunks/chunk-OKNFXCKX.js';
import './chunks/chunk-WITPEVRY.js';
import './chunks/chunk-CLB3BGGE.js';
import { closed_captions_on_default } from './chunks/chunk-24HGVM2L.js';
import { closed_captions_default } from './chunks/chunk-37XZ7737.js';
import './chunks/chunk-EP4MWRBL.js';
import './chunks/chunk-CGRGAJGZ.js';
import './chunks/chunk-6RLVDDBF.js';
import './chunks/chunk-XVRYXW3M.js';
import './chunks/chunk-74P2V52K.js';
import './chunks/chunk-XAR64F6F.js';
import './chunks/chunk-EQGP2ZMU.js';
import './chunks/chunk-ECRTHWE6.js';
import './chunks/chunk-MULRRSQ4.js';
import { createComment, listenEvent, mergeProperties, dispatchEvent, camelToKebabCase, ariaBool, isKeyboardEvent, isKeyboardClick, setAttribute, DOMEvent, createDisposalBin, setStyle, isDOMNode, flattenArray, createFragment, keysOf, useDisposalBin, appendTriggerEvent, createEvent, isDOMEvent, runAll, isDOMElement, EventsTarget, deferredPromise } from './chunks/chunk-FFBW6SEG.js';
import { signal, createContext, createStore, peek, isFunction2, isArray, effect2, useContext, isUndefined, onDispose, getScope, isNull, noop, scoped, computed, provideContext, getCustomElementInstance, ATTACH, CONNECT, isString, tick, unwrapDeep, isNumber, isObject, root, PROPS, SCOPE, RENDER, isBoolean, isFunction, effect, MEMBERS, untrack } from './chunks/chunk-GKRV3IQ4.js';
import './chunks/chunk-LRMOVTYW.js';
import './chunks/chunk-LEO6QOQ4.js';
import './chunks/chunk-ZJANC6WI.js';
import './chunks/chunk-M7HO525Z.js';
import './chunks/chunk-6OXP3LHR.js';

// ../../node_modules/.pnpm/maverick.js@0.33.1/node_modules/maverick.js/dist/dev/chunks/chunk-SLYTIALI.js
var createMarkerWalker = (root3) => (
  // @ts-expect-error - filter accepts `boolean` but not typed.
  document.createTreeWalker(root3, NodeFilter.SHOW_COMMENT, (node) => node.nodeValue === "$")
);
var hydration = null;
function runHydration(root3, renderer, options) {
  const prev = hydration;
  hydration = options.resume && hydration ? hydration : { w: createMarkerWalker(options.target) };
  const dispose = renderer(root3, options);
  hydration = prev;
  return dispose;
}
var CONNECTED = /* @__PURE__ */ Symbol("CONNECTED");
var INSERT_MARKER_NODE = createComment("$$");
var END_MARKER = /* @__PURE__ */ Symbol("END_MARKER");
var END_MARKER_NODE = /* @__PURE__ */ createComment("/$");
var ARRAY_END_MARKER_VALUE = "/[]";
function insertLite(parent, value, before) {
  let isSignal = isFunction2(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction2(value);
  }
  if (isSignal) {
    insertEffect(parent, value, before);
  } else if (!hydration && (value || value === 0)) {
    addChild(
      parent,
      isArray(value) ? resolveArray2(value) : isDOMNode(value) ? value : document.createTextNode(value + ""),
      before
    );
  }
}
function addChild(parent, node, before) {
  if (!node)
    return;
  if (before)
    parent.insertBefore(node, before);
  else
    parent.appendChild(node);
}
function insertEffect(parent, value, before) {
  const marker = before && before.nodeType === 8 ? before : INSERT_MARKER_NODE.cloneNode();
  if (marker !== before)
    addChild(parent, marker, before);
  effect2(() => void insertExpression2(marker, unwrapDeep(value)));
}
function insertExpression2(start, value) {
  const end = start[END_MARKER];
  if (isArray(value)) {
    if (hydration) {
      start[END_MARKER] = findArrayEndMarker(start);
    } else {
      if (end)
        removeOldNodes(start, end);
      const fragment = resolveArray2(value);
      if (!fragment)
        return;
      if (!end)
        fragment.appendChild(createEndMarker(start));
      start.after(fragment);
    }
  } else if (isDOMNode(value)) {
    if (end)
      removeOldNodes(start, end);
    if (!hydration)
      start.after(value);
    if (!end)
      value.after(createEndMarker(start));
  } else if (isString(value) || isNumber(value)) {
    if (start[CONNECTED]) {
      start.nextSibling.data = value + "";
      return;
    }
    if (end)
      removeOldNodes(start, end);
    let text;
    if (!hydration) {
      text = document.createTextNode(value + "");
      start.after(text);
    } else {
      text = start.nextSibling;
    }
    start[CONNECTED] = true;
    if (!end)
      text.after(createEndMarker(start));
  } else if (end) {
    removeOldNodes(start, end);
  }
}
function createEndMarker(start) {
  return start[END_MARKER] = END_MARKER_NODE.cloneNode();
}
function findArrayEndMarker(node) {
  while (node) {
    if (node.nodeType === 8 && node.nodeValue === ARRAY_END_MARKER_VALUE)
      return node;
    node = node.nextSibling;
  }
}
function removeOldNodes(start, end) {
  while (start.nextSibling !== end)
    start.nextSibling.remove();
  start[CONNECTED] = false;
}
function resolveArray2(value) {
  const flattened = flattenArray(value);
  if (!flattened.length)
    return null;
  const fragment = createFragment();
  for (let i = 0; i < flattened.length; i++) {
    const child = flattened[i];
    if (isFunction2(child)) {
      insertEffect(fragment, child);
    } else {
      fragment.append(child);
    }
  }
  return fragment;
}
function $$_create_template(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function $$_clone(fragment) {
  const clone = fragment.cloneNode(true);
  return clone.firstElementChild;
}
function $$_create_element(tagName) {
  return document.createElement(tagName);
}
var $$_insert_lite = insertLite;
function $$_create_component(component, props = {}) {
  return peek(() => component(props));
}
var $$CHILDREN = /* @__PURE__ */ Symbol("$$CHILDREN");
function $$_ref(element, ref) {
  if (isArray(ref)) {
    ref.filter(isFunction2).forEach((ref2) => ref2(element));
  } else if (isFunction2(ref)) {
    ref(element);
  }
}
var $$_attr = setAttribute;
function $$_inner_html(element, value) {
  if (isFunction2(value)) {
    effect2(() => {
      if (!hydration)
        element.innerHTML = value() + "";
    });
  } else if (!hydration) {
    element.innerHTML = value + "";
  }
}
function $$_listen(target, type, handler, capture = false) {
  if (isFunction2(handler)) {
    listenEvent(target, type, handler, { capture });
  }
}
var $$_effect = effect2;
function hydrateLite(root3, options) {
  return runHydration(root3, renderLite, options);
}
function renderLite(root3, options) {
  return root((dispose) => {
    if (!hydration) {
      insertLite(options.target, root3());
    } else {
      unwrapDeep(root3);
    }
    return dispose;
  });
}
function createHTMLElement(definition, init2) {
  var _a32;
  let attrToProp;
  let propToAttr;
  if (definition.props) {
    attrToProp = /* @__PURE__ */ new Map();
    propToAttr = /* @__PURE__ */ new Map();
    for (const propName of Object.keys(definition.props)) {
      const def = definition.props[propName];
      const attr = def.attribute;
      if (attr !== false) {
        const attrName = attr ?? camelToKebabCase(propName);
        attrToProp.set(attrName, propName);
        propToAttr.set(propName, attrName);
      }
    }
  }
  return _a32 = class extends HTMLCustomElement {
  }, _a32._definition = definition, _a32._init = init2, _a32._attrToProp = attrToProp, _a32._propToAttr = propToAttr, _a32;
}
var HTML_ELEMENT = HTMLElement;
var _a;
var HTMLCustomElement = class extends HTML_ELEMENT {
  constructor() {
    super();
    this._destroyed = false;
    this._instance = null;
    this._connectScope = null;
    this._attachCallbacks = /* @__PURE__ */ new Set();
    this._disconnectCallbacks = [];
    this.keepAlive = false;
    this[_a] = [];
    this._pendingSetup = false;
    const ctor = this.constructor;
    ctor._definition.construct?.call(this);
  }
  get _hydrate() {
    return this.hasAttribute("mk-h");
  }
  get _delegate() {
    return this.hasAttribute("mk-d");
  }
  get instance() {
    return this._instance;
  }
  static get observedAttributes() {
    return this._attrToProp ? Array.from(this._attrToProp.keys()) : [];
  }
  attributeChangedCallback(name, _, newValue) {
    const ctor = this.constructor;
    if (!this._instance || !ctor._attrToProp)
      return;
    const propName = ctor._attrToProp.get(name);
    const from = ctor._definition.props[propName]?.type?.from;
    if (from)
      this._instance[PROPS]["$" + propName].set(from(newValue));
  }
  connectedCallback() {
    const instance = this._instance;
    if (!this._delegate && !instance)
      return this._setup();
    if (!instance || !this.isConnected || instance.host.$connected())
      return;
    if (this._destroyed) {
      {
        throw Error(
          "[maverick] attempting to connect an element that has been destroyed"
        );
      }
    }
    if (this.hasAttribute("keep-alive"))
      this.keepAlive = true;
    instance.host[PROPS].$connected.set(true);
    tick();
    if (instance[CONNECT].length) {
      scoped(() => {
        root((dispose) => {
          this._connectScope = getScope();
          for (const connectCallback of instance[CONNECT]) {
            scoped(() => {
              const disconnectCallback = connectCallback();
              if (typeof disconnectCallback === "function") {
                this._disconnectCallbacks.push(disconnectCallback);
              }
            }, this._connectScope);
          }
          this._disconnectCallbacks.push(dispose);
        });
      }, instance[SCOPE]);
    }
    if (isArray(this[CONNECT])) {
      runAll(this[CONNECT]);
      this[CONNECT] = true;
    }
    tick();
    return;
  }
  disconnectedCallback() {
    const instance = this._instance;
    if (!instance?.host.$connected() || this._destroyed)
      return;
    instance.host[PROPS].$connected.set(false);
    tick();
    for (const disconnectCallback of this._disconnectCallbacks) {
      scoped(disconnectCallback, this._connectScope);
    }
    this._connectScope = null;
    tick();
    if (!this._delegate && !this.keepAlive) {
      requestAnimationFrame(() => {
        if (!this.isConnected) {
          instance?.destroy();
          this._destroyed = true;
        }
      });
    }
  }
  attachComponent(instance) {
    const ctor = this.constructor, definition = ctor._definition, init2 = ctor._init;
    if (this._instance) {
      console.warn(`[maverick] element \`${definition.tagName}\` already has attached component`);
    }
    if (this._destroyed) {
      console.warn(`[maverick] attempted attaching to destroyed element \`${definition.tagName}\``);
    }
    if (this._instance || this._destroyed)
      return;
    const $render = instance[RENDER];
    this._root = $render ? definition.shadowRoot ? this.shadowRoot ?? this.attachShadow(
      isBoolean(definition.shadowRoot) ? { mode: "open" } : definition.shadowRoot
    ) : resolveShadowRootElement(this) : null;
    if (definition.css && !init2?.adoptCSS) {
      console.warn(
        `[maverick] \`css\` was provided for \`${definition.tagName}\` but element registration doesn't support adopting stylesheets. Resolve this by registering element with \`registerElement\` instead of lite or headless.`
      );
    }
    if (!hydration && definition.shadowRoot && definition.css && init2?.adoptCSS) {
      init2.adoptCSS(this._root, definition.css);
    }
    const { $attrs, $styles } = instance.host[PROPS];
    for (const name of Object.keys($attrs)) {
      if (isFunction($attrs[name])) {
        effect(() => setAttribute(this, name, $attrs[name]()));
      } else {
        setAttribute(this, name, $attrs[name]);
      }
    }
    for (const name of Object.keys($styles)) {
      if (isFunction($styles[name])) {
        effect(() => setStyle(this, name, $styles[name]()));
      } else {
        setStyle(this, name, $styles[name]);
      }
    }
    instance.host[PROPS].$attrs = null;
    instance.host[PROPS].$styles = null;
    if (instance[MEMBERS]) {
      Object.defineProperties(this, Object.getOwnPropertyDescriptors(instance[MEMBERS]));
      instance[MEMBERS] = null;
    }
    instance.host.el = this;
    this._instance = instance;
    for (const attachCallback of [...instance[ATTACH], ...this._attachCallbacks]) {
      scoped(attachCallback, instance[SCOPE]);
    }
    this._attachCallbacks = null;
    if (this._root && init2 && $render) {
      const renderer = this._hydrate ? init2.hydrate : init2.render;
      renderer($render, {
        target: this._root,
        resume: !definition.shadowRoot
      });
    }
    tick();
    this.connectedCallback();
  }
  onAttach(callback) {
    if (this._instance) {
      callback();
      return noop;
    } else {
      this._attachCallbacks.add(callback);
      return () => this._attachCallbacks?.delete(callback);
    }
  }
  onEventDispatch(callback) {
    const ctor = this.constructor;
    if (ctor._dispatchedEvents)
      for (const eventType of ctor._dispatchedEvents)
        callback(eventType);
    this._onEventDispatch = callback;
  }
  destroy() {
    this.disconnectedCallback();
    this._instance?.destroy();
    this._instance = null;
    this._destroyed = true;
  }
  dispatchEvent(event) {
    if (this._delegate) {
      const ctor = this.constructor;
      if (!ctor._dispatchedEvents)
        ctor._dispatchedEvents = /* @__PURE__ */ new Set();
      if (!ctor._dispatchedEvents.has(event.type)) {
        this._onEventDispatch?.(event.type);
        ctor._dispatchedEvents.add(event.type);
      }
    }
    return untrack(() => super.dispatchEvent(event));
  }
  async _setup() {
    if (this._pendingSetup)
      return;
    this._pendingSetup = true;
    const { setup } = await import('./chunks/setup-JDTOOFMN-WHMDGT5V.js');
    await setup(this);
    this._pendingSetup = false;
  }
};
_a = CONNECT;
function resolveShadowRootElement(root3) {
  if (isDOMElement(root3.firstChild) && root3.firstChild.localName === "shadow-root") {
    return root3.firstChild;
  } else {
    const shadowRoot = $$_create_element("shadow-root");
    root3.prepend(shadowRoot);
    return shadowRoot;
  }
}
function defineCustomElement(declaration) {
  const definition = {
    ...declaration,
    setup(instance) {
      const setup = declaration.setup?.(
        instance
      ) ?? {};
      return isFunction2(setup) ? { $render: setup } : setup;
    }
  };
  if ("props" in definition) {
    for (const prop of Object.values(definition.props)) {
      if (prop.attribute !== false && !prop.type) {
        prop.type = inferAttributeType(prop.initial);
      }
    }
  }
  return definition;
}
var STRING = {
  from: (v) => v === null ? "" : v + ""
};
var NUMBER = {
  from: (v) => v === null ? 0 : Number(v)
};
var BOOLEAN = {
  from: (v) => v !== null,
  to: (v) => v ? "" : null
};
var FUNCTION = {
  from: false,
  to: () => null
};
var ARRAY = {
  from: (v) => v === null ? [] : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
var OBJECT = {
  from: (v) => v === null ? {} : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
function inferAttributeType(value) {
  switch (typeof value) {
    case "undefined":
      return STRING;
    case "string":
      return STRING;
    case "boolean":
      return BOOLEAN;
    case "number":
      return NUMBER;
    case "function":
      return FUNCTION;
    case "object":
      return isArray(value) ? ARRAY : OBJECT;
    default:
      return STRING;
  }
}
var createLifecycleMethod = (type) => {
  return (callback) => {
    const instance = getCustomElementInstance();
    if (!instance) {
      throw Error("[maverick] lifecycle hook called outside of element setup");
    }
    instance[type].push(callback);
  };
};
var onAttach = /* @__PURE__ */ createLifecycleMethod(ATTACH);
var onConnect = /* @__PURE__ */ createLifecycleMethod(CONNECT);
function registerLiteCustomElement(definition) {
  $registerCustomElement(definition, {
    render: renderLite,
    hydrate: hydrateLite
  });
}
function $registerCustomElement(definition, init2) {
  if (customElements.get(definition.tagName))
    return;
  customElements.define(definition.tagName, createHTMLElement(definition, init2));
}

// ../../node_modules/.pnpm/media-icons@0.4.2/node_modules/media-icons/dist/browser/index.js
var lazyPaths = {
  "add-note": () => import('./chunks/add-note-K6LY3JVJ-YLZC3ZRO.js'),
  "add-playlist": () => import('./chunks/add-playlist-V2PDG55Q-TN7MKKF6.js'),
  "add-user": () => import('./chunks/add-user-UODFHPUX-MENJSVWR.js'),
  "add": () => import('./chunks/add-MKWDO7OI-5ASE6LGD.js'),
  "airplay": () => import('./chunks/airplay-BBSPJ74C-IFFRVZAF.js'),
  "arrow-collapse-in": () => import('./chunks/arrow-collapse-in-YL2IDAI3-AQ6S3YBZ.js'),
  "arrow-collapse": () => import('./chunks/arrow-collapse-NIQ3FMMB-IFX4AQZZ.js'),
  "arrow-expand-out": () => import('./chunks/arrow-expand-out-5VKWMS7M-IVRVRAF5.js'),
  "arrow-expand": () => import('./chunks/arrow-expand-GB4FQX53-ND6O2BRN.js'),
  "arrow-left": () => import('./chunks/arrow-left-VMFA4MD3-AODF7KVX.js'),
  "bookmark": () => import('./chunks/bookmark-2HY3747X-CPXTE4NG.js'),
  "camera": () => import('./chunks/camera-MCHD22GI-4KCVZ4RD.js'),
  "chapters": () => import('./chunks/chapters-WZ5VBDWL-TTTOX3GD.js'),
  "chat-collapse": () => import('./chunks/chat-collapse-HT2BVQBQ-LKNHYJWS.js'),
  "chat": () => import('./chunks/chat-7SNHMFOE-P5R4ZQ52.js'),
  "chevron-down": () => import('./chunks/chevron-down-GHFOTKXU-ZK5FBODX.js'),
  "chevron-right": () => import('./chunks/chevron-right-RDCYIUTF-6UJJY3CY.js'),
  "chromecast": () => import('./chunks/chromecast-YZXROZN5-JPGRMECV.js'),
  "clip": () => import('./chunks/clip-UTUVK5ZJ-KY4HLBJO.js'),
  "closed-captions-on": () => import('./chunks/closed-captions-on-AWV5GKOR-I32CCOLL.js'),
  "closed-captions": () => import('./chunks/closed-captions-OL3H52PB-T5LQNWLE.js'),
  "comment": () => import('./chunks/comment-RHVNAV2Z-4NCTBA7P.js'),
  "computer": () => import('./chunks/computer-PDN53TBJ-ITNKVQ7E.js'),
  "device": () => import('./chunks/device-2Q4T5LRZ-CYN3ITMM.js'),
  "download": () => import('./chunks/download-VRWBBFI5-2HPAYEA3.js'),
  "episodes": () => import('./chunks/episodes-6LWZNPNN-DVE55O7P.js'),
  "eye": () => import('./chunks/eye-ARGO4OXU-LF54577Z.js'),
  "fast-backward": () => import('./chunks/fast-backward-KOWPJ77P-BE3ZYL6N.js'),
  "fast-forward": () => import('./chunks/fast-forward-YHUA2RUX-UW6OE57B.js'),
  "flag": () => import('./chunks/flag-7NS553YQ-6Y4IU37R.js'),
  "fullscreen-arrow-exit": () => import('./chunks/fullscreen-arrow-exit-UMGNEUBY-IJMG4RFA.js'),
  "fullscreen-arrow": () => import('./chunks/fullscreen-arrow-EAOJK5V6-XTEHY7HR.js'),
  "fullscreen-exit": () => import('./chunks/fullscreen-exit-5I5CX33N-367XYMWR.js'),
  "fullscreen": () => import('./chunks/fullscreen-6QBZ3YMF-AS2DQSFD.js'),
  "heart": () => import('./chunks/heart-QFV2QDNC-Z25TYBTL.js'),
  "info": () => import('./chunks/info-WIOFGZIX-2SF6YDFL.js'),
  "language": () => import('./chunks/language-6XZJKRI2-6F2AAFY2.js'),
  "link": () => import('./chunks/link-ML244RKU-SNVOLDRZ.js'),
  "lock-closed": () => import('./chunks/lock-closed-7PVUSTAD-IXEW5ZJT.js'),
  "lock-open": () => import('./chunks/lock-open-QLOH2QVT-KJV465OX.js'),
  "menu-horizontal": () => import('./chunks/menu-horizontal-KMADVH2U-U5ME3EIV.js'),
  "menu-vertical": () => import('./chunks/menu-vertical-VWVRRCQ4-26MSVEJ4.js'),
  "microphone": () => import('./chunks/microphone-UVDVU7A5-LAJNUCUP.js'),
  "mobile": () => import('./chunks/mobile-R5RKTMDN-UGSOONXZ.js'),
  "moon": () => import('./chunks/moon-LLSORKH7-ZL6CNYDA.js'),
  "music-off": () => import('./chunks/music-off-DYEDFBO2-GGFYKOK2.js'),
  "music": () => import('./chunks/music-SMN7SFSX-RRKN3YNO.js'),
  "mute": () => import('./chunks/mute-5ALLANKA-IW5ONAKY.js'),
  "next": () => import('./chunks/next-ADSQ667Q-PHKMLLMI.js'),
  "notification": () => import('./chunks/notification-5C3KPKVZ-J4ECYLKV.js'),
  "odometer": () => import('./chunks/odometer-VYJPIAWL-BWV5H3GZ.js'),
  "pause": () => import('./chunks/pause-KFO7OQUJ-5IU3YEVP.js'),
  "picture-in-picture-exit": () => import('./chunks/picture-in-picture-exit-74KJR6FY-UX3Q2HD2.js'),
  "picture-in-picture": () => import('./chunks/picture-in-picture-KJZV43E4-ET67D4SS.js'),
  "play": () => import('./chunks/play-JBRWVFR6-MSWKVN4J.js'),
  "playback-speed-circle": () => import('./chunks/playback-speed-circle-ZOSXV76B-PG4XHXE6.js'),
  "playlist": () => import('./chunks/playlist-NECHL7LX-M4SSHBUL.js'),
  "previous": () => import('./chunks/previous-OZJVKMBD-PDNX6LMX.js'),
  "question-mark": () => import('./chunks/question-mark-TIDUQQLU-I5Y2VNQL.js'),
  "queue-list": () => import('./chunks/queue-list-6AMVOMWO-ACPHP6SL.js'),
  "radio-button-selected": () => import('./chunks/radio-button-selected-DXL7XNW2-GEVGZ4T4.js'),
  "radio-button": () => import('./chunks/radio-button-Q3ADRHH7-ZCXZYZ4M.js'),
  "repeat-on": () => import('./chunks/repeat-on-AUI56XZD-B65W4H5A.js'),
  "repeat-square-on": () => import('./chunks/repeat-square-on-RXTHU34M-AWUKFVJK.js'),
  "repeat-square": () => import('./chunks/repeat-square-GMF4W5HF-3FUHUFAW.js'),
  "repeat": () => import('./chunks/repeat-QT2XRFPW-4VWYSZBC.js'),
  "replay": () => import('./chunks/replay-T2RUVYAH-5EXKGJZR.js'),
  "rotate": () => import('./chunks/rotate-KX4CNFR3-XCKLCHZY.js'),
  "search": () => import('./chunks/search-2JYKNW4X-63MNKROJ.js'),
  "seek-backward-10": () => import('./chunks/seek-backward-10-Z6KZ4QTT-GL6HNBK7.js'),
  "seek-backward-15": () => import('./chunks/seek-backward-15-Y4M7ZUTB-WTSNBSJO.js'),
  "seek-backward-30": () => import('./chunks/seek-backward-30-KL5HTV4A-7K7SKQ5M.js'),
  "seek-backward": () => import('./chunks/seek-backward-725VG7KT-KD2K26NQ.js'),
  "seek-forward-10": () => import('./chunks/seek-forward-10-KH6RHT7A-ETGCQR33.js'),
  "seek-forward-15": () => import('./chunks/seek-forward-15-RHQSPHCS-HSD2F47E.js'),
  "seek-forward-30": () => import('./chunks/seek-forward-30-BJUOSAZO-SPVSSJMJ.js'),
  "seek-forward": () => import('./chunks/seek-forward-PT5LOJZQ-OGPY2VNE.js'),
  "send": () => import('./chunks/send-LM6WLRAI-73QRZJFV.js'),
  "settings-menu": () => import('./chunks/settings-menu-TPGMH5JT-LAVQ2ADS.js'),
  "settings-switch": () => import('./chunks/settings-switch-TUFPX7FQ-YCLFVGX2.js'),
  "settings": () => import('./chunks/settings-NIOTEDBE-RH3VHI3K.js'),
  "share-arrow": () => import('./chunks/share-arrow-QWD5PQVS-IKTTOQCE.js'),
  "share": () => import('./chunks/share-HMHTXN7I-75E6GI5I.js'),
  "shuffle-on": () => import('./chunks/shuffle-on-CKD7E2HN-CHUSZW4Q.js'),
  "shuffle": () => import('./chunks/shuffle-BUFG4YJQ-CHDKBCAX.js'),
  "stop": () => import('./chunks/stop-ZU2CJPIA-HI6UU2AW.js'),
  "subtitles": () => import('./chunks/subtitles-DXOKQAOQ-5EWOUN6G.js'),
  "sun": () => import('./chunks/sun-3URLHARM-M2WF7524.js'),
  "theatre-mode-exit": () => import('./chunks/theatre-mode-exit-NYUOZTLG-JY4BZ2NS.js'),
  "theatre-mode": () => import('./chunks/theatre-mode-YZ37QE62-AJMLL6O4.js'),
  "thumbs-down": () => import('./chunks/thumbs-down-PB3QBVDG-CCAOUMOY.js'),
  "thumbs-up": () => import('./chunks/thumbs-up-KR3RGBXP-43WNHYCL.js'),
  "timer": () => import('./chunks/timer-LEKSHLMO-QB2BHJJF.js'),
  "transcript": () => import('./chunks/transcript-WBVAFRPP-JDS3M3XA.js'),
  "tv": () => import('./chunks/tv-BBPMIKYK-GLCKSXO4.js'),
  "user": () => import('./chunks/user-XLENPSJP-AVKOXGZ5.js'),
  "volume-high": () => import('./chunks/volume-high-QFIQXACF-WAL7YLS4.js'),
  "volume-low": () => import('./chunks/volume-low-7G4R22Y3-7Z5N7MSK.js'),
  "x-mark": () => import('./chunks/x-mark-ORJKYZQ2-OWS2WCLR.js')
};

// src/icons/element.tsx
var $$_templ = /* @__PURE__ */ $$_create_template(`<svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" data-media-icon="true"></svg>`);
var MediaIconDefinition = defineCustomElement({
  tagName: "media-icon",
  props: {
    type: {}
  },
  setup({ host, props: { $type }, accessors }) {
    const $paths = signal("");
    onAttach(() => {
      let hydrate2 = host.el.hasAttribute("mk-h");
      effect2(() => {
        const type = $type();
        if (hydrate2) {
          hydrate2 = false;
          return;
        }
        if (type && lazyPaths[type]) {
          lazyPaths[type]().then(({ default: paths2 }) => {
            if (type === peek($type))
              $paths.set(paths2);
          });
        } else
          $paths.set("");
      });
    });
    return mergeProperties(accessors(), {
      $render: () => (() => {
        const $$_root = $$_clone($$_templ);
        $$_inner_html($$_root, $paths);
        return $$_root;
      })()
    });
  }
});

// src/foundation/logger/colors.ts
var LOCAL_STORAGE_KEY = "@vidstack/log-colors";
var savedColors = init();
function getLogColor(key2) {
  return savedColors.get(key2);
}
function saveLogColor(key2, { color = generateColor(), overwrite = false } = {}) {
  if (!savedColors.has(key2) || overwrite) {
    savedColors.set(key2, color);
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Object.entries(savedColors)));
  }
}
function generateColor() {
  return `hsl(${Math.random() * 360}, 55%, 70%)`;
}
function init() {
  let colors;
  try {
    colors = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));
  } catch {
  }
  return new Map(Object.entries(colors ?? {}));
}

// src/foundation/logger/create-grouped-log.ts
var GROUPED_LOG = Symbol("GROUPED_LOG");
function isGroupedLog(data) {
  return isObject(data) && data[GROUPED_LOG];
}
function createGroupedLog(title, parent) {
  const logs = [];
  const group = {
    [GROUPED_LOG]: true,
    title,
    logs,
    log(...data) {
      logs.push({ data });
      return group;
    },
    labelledLog(label, ...data) {
      logs.push({ label, data });
      return group;
    },
    groupStart(title2) {
      return createGroupedLog(title2, group);
    },
    groupEnd() {
      parent?.logs.push(group);
      return parent ?? group;
    }
  };
  return group;
}

// src/foundation/logger/log-level.ts
var LogLevelValue = Object.freeze({
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
});
var LogLevelColor = Object.freeze({
  silent: "white",
  error: "hsl(6, 58%, 50%)",
  warn: "hsl(51, 58%, 50%)",
  info: "hsl(219, 58%, 50%)",
  debug: "hsl(280, 58%, 50%)"
});

// src/foundation/logger/ms.ts
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
function ms(val) {
  const msAbs = Math.abs(val);
  if (msAbs >= d) {
    return Math.round(val / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(val / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(val / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(val / s) + "s";
  }
  return round(val, 2) + "ms";
}

// src/foundation/logger/log-printer.ts
function createLogPrinter($target) {
  let logLevel = "warn", lastLogTimestamp = void 0;
  effect2(() => {
    const target = $target();
    if (!target)
      return;
    listenEvent(target, "vds-log", (event) => {
      event.stopPropagation();
      const eventTargetName = (event.path?.[0] ?? event.target).tagName.toLowerCase();
      const { level = "warn", data } = event.detail ?? {};
      if (LogLevelValue[logLevel] < LogLevelValue[level]) {
        return;
      }
      saveLogColor(eventTargetName);
      const hint = data?.length === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data?.[0]) ? data[0] : "";
      console.groupCollapsed(
        `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? "..." : ""}`,
        `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,
        `color: ${getLogColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,
        "color: gray; font-size: 11px; padding-left: 4px;"
      );
      if (data?.length === 1 && isGroupedLog(data[0])) {
        printGroup(level, data[0]);
      } else if (data) {
        print(level, ...data);
      }
      printTimeDiff();
      printStackTrace();
      console.groupEnd();
    });
    return () => {
      lastLogTimestamp = void 0;
    };
  });
  const calcLastLogTimeDiff = () => {
    const time = performance.now();
    const diff = time - (lastLogTimestamp ?? (lastLogTimestamp = performance.now()));
    lastLogTimestamp = time;
    return ms(diff);
  };
  const printTimeDiff = () => {
    labelledPrint("Time since last log", calcLastLogTimeDiff());
  };
  return {
    get logLevel() {
      return logLevel;
    },
    set logLevel(level) {
      logLevel = level;
    }
  };
}
function print(level, ...data) {
  console[level](...data);
}
function labelledPrint(label, ...data) {
  console.log(`%c${label}:`, "color: gray", ...data);
}
function printStackTrace() {
  console.groupCollapsed("%cStack Trace", "color: gray");
  console.trace();
  console.groupEnd();
}
function printGroup(level, groupedLog) {
  console.groupCollapsed(groupedLog.title);
  for (const log of groupedLog.logs) {
    if (isGroupedLog(log)) {
      printGroup(level, log);
    } else if ("label" in log && !isUndefined(log.label)) {
      labelledPrint(log.label, ...log.data);
    } else {
      print(level, ...log.data);
    }
  }
  console.groupEnd();
}

// src/foundation/observers/use-focus-visible.ts
var $keyboard = signal(false);
{
  listenEvent(document, "pointerdown", () => {
    $keyboard.set(false);
  });
  listenEvent(document, "keydown", (e) => {
    if (e.metaKey || e.altKey || e.ctrlKey)
      return;
    $keyboard.set(true);
  });
}
function useFocusVisible($target) {
  const $focused = signal(false);
  onConnect(() => {
    const target = $target();
    effect2(() => {
      if (!$keyboard()) {
        $focused.set(false);
        updateFocusAttr(target, false);
        listenEvent(target, "pointerenter", () => updateHoverAttr(target, true));
        listenEvent(target, "pointerleave", () => updateHoverAttr(target, false));
        return;
      }
      const active = document.activeElement === target;
      $focused.set(active);
      updateFocusAttr(target, active);
      listenEvent(target, "focus", () => {
        $focused.set(true);
        updateFocusAttr(target, true);
      });
      listenEvent(target, "blur", () => {
        $focused.set(false);
        updateFocusAttr(target, false);
      });
    });
  });
  return $focused;
}
function updateFocusAttr(target, isFocused) {
  setAttribute(target, "data-focus", isFocused);
  setAttribute(target, "data-hocus", isFocused);
}
function updateHoverAttr(target, isHovering) {
  setAttribute(target, "data-hocus", isHovering);
}

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js
var key = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
};
var webkit = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
];
var moz = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
];
var ms2 = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
];
var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
var vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms2[0] in document2 && ms2 || [];
var fscreen = {
  requestFullscreen: function(element) {
    return element[vendor[key.requestFullscreen]]();
  },
  requestFullscreenFunction: function(element) {
    return element[vendor[key.requestFullscreen]];
  },
  get exitFullscreen() {
    return document2[vendor[key.exitFullscreen]].bind(document2);
  },
  get fullscreenPseudoClass() {
    return ":" + vendor[key.fullscreen];
  },
  addEventListener: function(type, handler, options) {
    return document2.addEventListener(vendor[key[type]], handler, options);
  },
  removeEventListener: function(type, handler, options) {
    return document2.removeEventListener(vendor[key[type]], handler, options);
  },
  get fullscreenEnabled() {
    return Boolean(document2[vendor[key.fullscreenEnabled]]);
  },
  set fullscreenEnabled(val) {
  },
  get fullscreenElement() {
    return document2[vendor[key.fullscreenElement]];
  },
  set fullscreenElement(val) {
  },
  get onfullscreenchange() {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(handler) {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
  },
  get onfullscreenerror() {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(handler) {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
  }
};
var fscreen_esm_default = fscreen;

// src/foundation/fullscreen/fullscreen.ts
function createFullscreenAdapter($target) {
  const $active = signal(false), exit = () => exitFullscreen(peek($target));
  let listening = false;
  effect2(() => {
    const target = $target();
    if (target) {
      listenEvent(fscreen_esm_default, "fullscreenchange", async (trigger) => {
        const active = isFullscreen(target);
        if (active === $active())
          return;
        if (!active)
          listening = false;
        $active.set(active);
        dispatchEvent(target, "fullscreen-change", { detail: active, trigger });
      });
      listenEvent(fscreen_esm_default, "fullscreenerror", (trigger) => {
        if (!listening)
          return;
        dispatchEvent(target, "fullscreen-error", { detail: null, trigger });
        listening = false;
      });
      return async () => {
        if (canFullscreen())
          await exit();
      };
    }
    return;
  });
  return {
    get active() {
      return $active();
    },
    get supported() {
      return canFullscreen();
    },
    async enter() {
      try {
        listening = true;
        return await requestFullscreen(peek($target));
      } catch (error) {
        listening = false;
        throw error;
      }
    },
    exit
  };
}
function canFullscreen() {
  return fscreen_esm_default.fullscreenEnabled;
}
function isFullscreen(host) {
  if (fscreen_esm_default.fullscreenElement === host)
    return true;
  try {
    return host.matches(
      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
      fscreen_esm_default.fullscreenPseudoClass
    );
  } catch (error) {
    return false;
  }
}
async function requestFullscreen(host) {
  if (!host || isFullscreen(host))
    return;
  assertFullscreenAPI();
  return fscreen_esm_default.requestFullscreen(host);
}
async function exitFullscreen(host) {
  if (!host || !isFullscreen(host))
    return;
  assertFullscreenAPI();
  return fscreen_esm_default.exitFullscreen();
}
function assertFullscreenAPI() {
  if (canFullscreen())
    return;
  throw Error(
    "[vidstack] fullscreen API is not enabled or supported in this environment" 
  );
}

// src/foundation/logger/dispatch.ts
function dispatchLogEvent(target, level, ...data) {
  return dispatchEvent(target, "vds-log", {
    bubbles: true,
    composed: true,
    detail: { level, data }
  });
}

// src/foundation/logger/create-logger.ts
function createLogger() {
  let target = null;
  const createGroupedLogger = (level, title, rootGroup, parentGroup) => {
    const group = createGroupedLog(title, parentGroup);
    group.dispatch = () => dispatchLogEvent(target, level, rootGroup ?? group);
    return {
      ...group,
      groupStart: (title2) => createGroupedLogger(level, title2, rootGroup ?? group, group)
    };
  };
  return {
    error: (...data) => dispatchLogEvent(target, "error", ...data),
    warn: (...data) => dispatchLogEvent(target, "warn", ...data),
    info: (...data) => dispatchLogEvent(target, "info", ...data),
    debug: (...data) => dispatchLogEvent(target, "debug", ...data),
    errorGroup: (title) => createGroupedLogger("error", title),
    warnGroup: (title) => createGroupedLogger("warn", title),
    infoGroup: (title) => createGroupedLogger("info", title),
    debugGroup: (title) => createGroupedLogger("debug", title),
    setTarget: (newTarget) => {
      target = newTarget;
    }
  };
}

// src/foundation/logger/logger.ts
var loggers = /* @__PURE__ */ new WeakMap();
function useLogger($target) {
  const logger = loggers.get($target) ?? createLogger();
  if (!loggers.has($target)) {
    effect2(() => logger.setTarget($target()));
    loggers.set($target, logger);
  }
  return logger;
}

// src/player/media/context.ts
var mediaContext = createContext();
function useMedia() {
  return useContext(mediaContext);
}

// src/foundation/list/list.ts
var _a3;
var List = class extends EventsTarget {
  constructor() {
    super(...arguments);
    this._items = [];
    /* @internal */
    this[_a3] = false;
  }
  get length() {
    return this._items.length;
  }
  get readonly() {
    return this[LIST_READONLY];
  }
  /**
   * Transform list to an array.
   */
  toArray() {
    return [...this._items];
  }
  [(_a3 = LIST_READONLY, Symbol.iterator)]() {
    return this._items.values();
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    const index = this._items.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get() {
          return this._items[index];
        }
      });
    }
    if (this._items.includes(item))
      return;
    this._items.push(item);
    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
  }
  /* @internal */
  [LIST_REMOVE](item, trigger) {
    const index = this._items.indexOf(item);
    if (index >= 0) {
      this[LIST_ON_REMOVE]?.(item, trigger);
      this._items.splice(index, 1);
      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
    }
  }
  /* @internal */
  [LIST_RESET](trigger) {
    for (const item of [...this._items])
      this[LIST_REMOVE](item, trigger);
    this._items = [];
    this[LIST_SET_READONLY](false, trigger);
    this[LIST_ON_RESET]?.();
  }
  /* @internal */
  [LIST_SET_READONLY](readonly, trigger) {
    if (this[LIST_READONLY] === readonly)
      return;
    this[LIST_READONLY] = readonly;
    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
  }
};

// src/foundation/list/select-list.ts
var SELECTED = Symbol("SELECTED" );
var SelectList = class extends List {
  get selected() {
    return this._items.find((item) => item.selected) ?? null;
  }
  get selectedIndex() {
    return this._items.findIndex((item) => item.selected);
  }
  /* @internal */
  [LIST_ON_REMOVE](item, trigger) {
    this[LIST_SELECT](item, false, trigger);
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    item[SELECTED] = false;
    Object.defineProperty(item, "selected", {
      get() {
        return this[SELECTED];
      },
      set: (selected) => {
        if (this.readonly)
          return;
        this[LIST_ON_USER_SELECT]?.();
        this[LIST_SELECT](item, selected);
      }
    });
    super[LIST_ADD](item, trigger);
  }
  /* @internal */
  [LIST_SELECT](item, selected, trigger) {
    if (selected === item[SELECTED])
      return;
    const prev = this.selected;
    item[SELECTED] = selected;
    const changed = !selected ? prev === item : prev !== item;
    if (changed) {
      if (prev)
        prev[SELECTED] = false;
      this.dispatchEvent(
        new DOMEvent("change", {
          detail: { prev, current: this.selected },
          trigger
        })
      );
    }
  }
};

// src/player/media/quality/video-quality.ts
var VideoQualityList = class extends SelectList {
  constructor() {
    super(...arguments);
    this._auto = false;
    /**
     * Configures quality switching:
     *
     * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
     * request if any, flush the whole buffer, and fetch fragment matching with current position
     * and requested quality level.
     *
     * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
     * already buffered next fragment.
     *
     * - `load`: Set quality level for next loaded fragment.
     *
     * @see {@link https://vidstack.io/docs/player/core-concepts/quality#switch}
     * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
     */
    this.switch = "current";
  }
  /**
   * Whether automatic quality selection is enabled.
   */
  get auto() {
    return this._auto || this.readonly;
  }
  /* @internal */
  [(LIST_ON_USER_SELECT)]() {
    this[SET_AUTO_QUALITY](false);
  }
  /* @internal */
  [LIST_ON_RESET](trigger) {
    this[SET_AUTO_QUALITY](false, trigger);
  }
  /**
   * Request automatic quality selection (if supported). This will be a no-op if the list is
   * `readonly` as that already implies auto-selection.
   */
  autoSelect(trigger) {
    if (this.readonly || this._auto || !this[ENABLE_AUTO_QUALITY])
      return;
    this[ENABLE_AUTO_QUALITY]();
    this[SET_AUTO_QUALITY](true, trigger);
  }
  /* @internal */
  [SET_AUTO_QUALITY](auto, trigger) {
    if (this._auto === auto)
      return;
    this._auto = auto;
    this.dispatchEvent(
      new DOMEvent("auto-change", {
        detail: auto,
        trigger
      })
    );
  }
};

// src/player/media/remote-control.ts
var MediaRemoteControl = class {
  constructor(_logger) {
    this._logger = _logger;
    this._target = null;
    this._player = null;
    this._prevTrackIndex = -1;
  }
  /**
   * Set the target from which to dispatch media requests events from. The events should bubble
   * up from this target to the `<media-player>` element.
   *
   * @example
   * ```ts
   * const button = document.querySelector('button');
   * remote.setTarget(button);
   * ```
   */
  setTarget(target) {
    this._target = target;
    this._logger?.setTarget(target);
  }
  /**
   * Returns the current `<media-player>` element. This method will attempt to find the player by
   * searching up from either the given `target` or default target set via `remote.setTarget`.
   *
   * @example
   * ```ts
   * const player = remote.getPlayer();
   * ```
   */
  getPlayer(target) {
    if (this._player)
      return this._player;
    (target ?? this._target)?.dispatchEvent(
      new DOMEvent("find-media-player", {
        detail: (player) => void (this._player = player),
        bubbles: true,
        composed: true
      })
    );
    return this._player;
  }
  /**
   * Set the current `<media-player>` element so the remote can support toggle methods such as
   * `togglePaused` as they rely on the current media state.
   */
  setPlayer(player) {
    this._player = player;
  }
  /**
   * Dispatch a request to start the media loading process. This will only work if the media
   * player has been initialized with a custom loading strategy `<media-player load="custom">`.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#loading-strategies}
   */
  startLoading(trigger) {
    this._dispatchRequest("media-start-loading", trigger);
  }
  /**
   * Dispatch a request to begin/resume media playback.
   */
  play(trigger) {
    this._dispatchRequest("media-play-request", trigger);
  }
  /**
   * Dispatch a request to pause media playback.
   */
  pause(trigger) {
    this._dispatchRequest("media-pause-request", trigger);
  }
  /**
   * Dispatch a request to set the media volume to mute (0).
   */
  mute(trigger) {
    this._dispatchRequest("media-mute-request", trigger);
  }
  /**
   * Dispatch a request to unmute the media volume and set it back to it's previous state.
   */
  unmute(trigger) {
    this._dispatchRequest("media-unmute-request", trigger);
  }
  /**
   * Dispatch a request to enter fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  enterFullscreen(target, trigger) {
    this._dispatchRequest("media-enter-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to exit fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  exitFullscreen(target, trigger) {
    this._dispatchRequest("media-exit-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to enter picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  enterPictureInPicture(trigger) {
    this._dispatchRequest("media-enter-pip-request", trigger);
  }
  /**
   * Dispatch a request to exit picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  exitPictureInPicture(trigger) {
    this._dispatchRequest("media-exit-pip-request", trigger);
  }
  /**
   * Notify the media player that a seeking process is happening and to seek to the given `time`.
   */
  seeking(time, trigger) {
    this._dispatchRequest("media-seeking-request", trigger, time);
  }
  /**
   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
   * This is generally called after a series of `remote.seeking()` calls.
   */
  seek(time, trigger) {
    this._dispatchRequest("media-seek-request", trigger, time);
  }
  seekToLiveEdge(trigger) {
    this._dispatchRequest("media-live-edge-request", trigger);
  }
  /**
   * Dispatch a request to update the media volume to the given `volume` level which is a value
   * between 0 and 1.
   *
   * @example
   * ```ts
   * remote.changeVolume(0); // 0%
   * remote.changeVolume(0.05); // 5%
   * remote.changeVolume(0.5); // 50%
   * remote.changeVolume(0.75); // 70%
   * remote.changeVolume(1); // 100%
   * ```
   */
  changeVolume(volume, trigger) {
    this._dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
  }
  /**
   * Dispatch a request to change the current audio track.
   *
   * @example
   * ```ts
   * remote.changeAudioTrack(1); // track at index 1
   * ```
   */
  changeAudioTrack(index, trigger) {
    this._dispatchRequest("media-audio-track-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
   * selection.
   *
   * @example
   * ```ts
   * remote.changeQuality(-1); // auto
   * remote.changeQuality(1); // quality at index 1
   * ```
   */
  changeQuality(index, trigger) {
    this._dispatchRequest("media-quality-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the mode of the text track at the given index.
   *
   * @example
   * ```ts
   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
   * ```
   */
  changeTextTrackMode(index, mode, trigger) {
    this._dispatchRequest("media-text-track-change-request", trigger, {
      index,
      mode
    });
  }
  /**
   * Dispatch a request to change the media playback rate.
   *
   * @example
   * ```ts
   * remote.changePlaybackRate(0.5); // Half the normal speed
   * remote.changePlaybackRate(1); // Normal speed
   * remote.changePlaybackRate(1.5); // 50% faster than normal
   * remote.changePlaybackRate(2); // Double the normal speed
   * ```
   */
  changePlaybackRate(rate, trigger) {
    this._dispatchRequest("media-rate-change-request", trigger, rate);
  }
  /**
   * Dispatch a request to resume user idle tracking. Refer to {@link MediaRemoteControl.pauseUserIdle}
   * for more information.
   */
  resumeUserIdle(trigger) {
    this._dispatchRequest("media-resume-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to pause user idle tracking. Pausing tracking will result in the `user-idle`
   * attribute and state being `false` until `remote.resumeUserIdle()` is called. This method
   * is generally used when building custom controls and you'd like to prevent the UI from
   * dissapearing.
   *
   * @example
   * ```ts
   * // Prevent user idling while menu is being interacted with.
   * function onSettingsOpen() {
   *   remote.pauseUserIdle();
   * }
   *
   * function onSettingsClose() {
   *   remote.resumeUserIdle();
   * }
   * ```
   */
  pauseUserIdle(trigger) {
    this._dispatchRequest("media-pause-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to load and show the native poster element.
   */
  showPoster(trigger) {
    this._dispatchRequest("media-show-poster-request", trigger);
  }
  /**
   * Dispatch a request to prevent loading and to hide the native poster element.
   */
  hidePoster(trigger) {
    this._dispatchRequest("media-hide-poster-request", trigger);
  }
  /**
   * Dispatch a request to toggle the media playback state.
   */
  togglePaused(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.togglePaused.name);
      return;
    }
    if (player.state.paused)
      this.play(trigger);
    else
      this.pause(trigger);
  }
  /**
   * Dispatch a request to toggle the media muted state.
   */
  toggleMuted(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.toggleMuted.name);
      return;
    }
    if (player.state.muted)
      this.unmute(trigger);
    else
      this.mute(trigger);
  }
  /**
   * Dispatch a request to toggle the media fullscreen state.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  toggleFullscreen(target, trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.toggleFullscreen.name);
      return;
    }
    if (player.state.fullscreen)
      this.exitFullscreen(target, trigger);
    else
      this.enterFullscreen(target, trigger);
  }
  /**
   * Dispatch a request to toggle the media picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  togglePictureInPicture(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.togglePictureInPicture.name);
      return;
    }
    if (player.state.pictureInPicture)
      this.exitPictureInPicture(trigger);
    else
      this.enterPictureInPicture(trigger);
  }
  /**
   * Dispatch a request to toggle the current captions mode.
   */
  toggleCaptions(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.toggleCaptions.name);
      return;
    }
    const tracks = player.state.textTracks, track = player.state.textTrack;
    if (track) {
      const index = tracks.indexOf(track);
      this.changeTextTrackMode(index, "disabled", trigger);
      this._prevTrackIndex = index;
    } else {
      let index = this._prevTrackIndex;
      if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
        index = -1;
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2) && track2.default);
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2));
      }
      if (index >= 0)
        this.changeTextTrackMode(index, "showing", trigger);
      this._prevTrackIndex = -1;
    }
  }
  _dispatchRequest(type, trigger, detail) {
    const request = new DOMEvent(type, {
      bubbles: true,
      composed: true,
      detail,
      trigger
    });
    const target = trigger?.target === document || trigger?.target === window || trigger?.target === document.body ? this._target ?? this.getPlayer() : trigger?.target ?? this._target;
    {
      this._logger?.infoGroup(`\u{1F4E8} dispatching \`${type}\``).labelledLog("Target", target).labelledLog("Player", this._player).labelledLog("Request Event", request).labelledLog("Trigger Event", trigger).dispatch();
    }
    target?.dispatchEvent(request);
  }
  _noPlayerWarning(method) {
    {
      console.warn(
        `[vidstack] attempted to call \`MediaRemoteControl.${method}\`() that requires player but failed because remote could not find a parent player element from target`
      );
    }
  }
};

// src/player/media/time-ranges.ts
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  throwIfOutOfRange(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex] || Infinity;
}
function buildTimeRanges(ranges) {
  if (isUndefined(ranges) || ranges.length === 0) {
    return { length: 0, start: emptyTimeRange, end: emptyTimeRange };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, "start", 0, ranges),
    end: getRange.bind(null, "end", 1, ranges)
  };
}
function createTimeRanges(start, end) {
  if (isArray(start)) {
    return buildTimeRanges(start);
  } else if (isUndefined(start) || isUndefined(end)) {
    return buildTimeRanges();
  }
  return buildTimeRanges([[start, end]]);
}
function getTimeRangesStart(ranges) {
  if (!ranges.length)
    return null;
  let min = ranges.start(0);
  for (let i = 1; i < ranges.length; i++) {
    const value = ranges.start(i);
    if (value < min)
      min = value;
  }
  return min;
}
function getTimeRangesEnd(ranges) {
  if (!ranges.length)
    return null;
  let max = ranges.end(0);
  for (let i = 1; i < ranges.length; i++) {
    const value = ranges.end(i);
    if (value > max)
      max = value;
  }
  return max;
}
function throwIfOutOfRange(fnName, index, end) {
  if (!isNumber(index) || index < 0 || index > end) {
    throw new Error(
      `Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${end}).`
    );
  }
}
function emptyTimeRange() {
  throw new Error("`TimeRanges` object is empty." );
}

// src/player/media/store.ts
var mediaStore = createStore({
  audioTracks: [],
  audioTrack: null,
  autoplay: false,
  autoplayError: void 0,
  buffered: createTimeRanges(),
  duration: 0,
  canLoad: false,
  canFullscreen: false,
  canPictureInPicture: false,
  canPlay: false,
  controls: false,
  crossorigin: null,
  poster: "",
  currentTime: 0,
  ended: false,
  error: void 0,
  fullscreen: false,
  loop: false,
  logLevel: "warn" ,
  mediaType: "unknown",
  muted: false,
  paused: true,
  played: createTimeRanges(),
  playing: false,
  playsinline: false,
  pictureInPicture: false,
  preload: "metadata",
  playbackRate: 1,
  qualities: [],
  quality: null,
  autoQuality: false,
  canSetQuality: true,
  seekable: createTimeRanges(),
  seeking: false,
  source: { src: "", type: "" },
  sources: [],
  started: false,
  textTracks: [],
  textTrack: null,
  volume: 1,
  waiting: false,
  get viewType() {
    return this.providedViewType !== "unknown" ? this.providedViewType : this.mediaType;
  },
  get streamType() {
    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
  },
  get currentSrc() {
    return this.source;
  },
  get bufferedStart() {
    return getTimeRangesStart(this.buffered) ?? 0;
  },
  get bufferedEnd() {
    return getTimeRangesEnd(this.buffered) ?? 0;
  },
  get seekableStart() {
    return getTimeRangesStart(this.seekable) ?? 0;
  },
  get seekableEnd() {
    return this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
  },
  get seekableWindow() {
    return Math.max(0, this.seekableEnd - this.seekableStart);
  },
  // ~~ user props ~~
  userIdle: false,
  userBehindLiveEdge: false,
  // ~~ live props ~~
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  get canSeek() {
    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);
  },
  get live() {
    return this.streamType.includes("live") || !Number.isFinite(this.duration);
  },
  get liveEdgeStart() {
    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;
  },
  get liveEdge() {
    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
  },
  get liveEdgeWindow() {
    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
  },
  // ~~ internal props ~~
  attemptingAutoplay: false,
  canLoadPoster: null,
  providedViewType: "unknown",
  providedStreamType: "unknown",
  inferredStreamType: "unknown",
  liveSyncPosition: null
});
var DO_NOT_RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
  "autoplay",
  "canFullscreen",
  "canPictureInPicture",
  "canLoad",
  "controls",
  "fullscreen",
  "loop",
  "logLevel",
  "muted",
  "playsinline",
  "pictureInPicture",
  "preload",
  "poster",
  "source",
  "sources",
  "textTracks",
  "textTrack",
  "volume",
  "canLoadPoster",
  "providedStreamType",
  "providedViewType"
]);
function softResetMediaStore($media) {
  mediaStore.reset($media, (prop) => !DO_NOT_RESET_ON_SRC_CHANGE.has(prop));
  tick();
}

// src/player/media/tracks/audio-tracks.ts
var AudioTrackList = class extends SelectList {
  getById(id) {
    if (id === "")
      return null;
    return this._items.find((track) => track.id === id) ?? null;
  }
};

// src/player/media/tracks/text/render/native-text-renderer.ts
var NativeTextRenderer = class {
  constructor() {
    this.priority = 0;
    this._display = true;
    this._video = null;
    this._track = null;
    this._tracks = /* @__PURE__ */ new Set();
  }
  canRender() {
    return true;
  }
  attach(video) {
    this._video = video;
    if (!video.crossOrigin)
      video.crossOrigin = "anonymous";
    video.textTracks.onchange = this._onChange.bind(this);
  }
  addTrack(track) {
    this._tracks.add(track);
    this._attachTrack(track);
  }
  removeTrack(track) {
    track[TEXT_TRACK_NATIVE]?.remove?.();
    track[TEXT_TRACK_NATIVE] = null;
    this._tracks.delete(track);
  }
  changeTrack(track) {
    const prev = this._track?.[TEXT_TRACK_NATIVE], current = track?.[TEXT_TRACK_NATIVE];
    if (prev && this._track !== track)
      prev.track.mode = "disabled";
    if (current)
      current.track.mode = "showing";
    this._track = track;
  }
  setDisplay(display) {
    this._display = display;
  }
  detach() {
    if (this._video)
      this._video.textTracks.onchange = null;
    for (const track of this._tracks)
      this.removeTrack(track);
    this._tracks.clear();
    this._video = null;
    this._track = null;
  }
  _attachTrack(track) {
    var _a4;
    if (!this._video)
      return;
    const el = track[_a4 = TEXT_TRACK_NATIVE] ?? (track[_a4] = this._createTrackElement(track));
    if (el instanceof HTMLElement)
      this._video.append(el);
  }
  _createTrackElement(track) {
    const el = document.createElement("track");
    el.src = "https://cdn.jsdelivr.net/npm/vidstack/empty.vtt";
    el.id = track.id;
    el.label = track.label;
    el.kind = track.kind;
    el.default = track.default;
    track.language && (el.srclang = track.language);
    return el;
  }
  _copyCues(track, native) {
    if (native.cues?.length)
      return;
    for (const cue of track.cues)
      native.addCue(cue);
  }
  _onChange(event) {
    for (const track of this._tracks) {
      const nativeTrack = track[TEXT_TRACK_NATIVE]?.track;
      if (!nativeTrack)
        continue;
      if (!this._display) {
        nativeTrack.mode = "disabled";
        continue;
      }
      if (nativeTrack.mode === "showing") {
        this._copyCues(track, nativeTrack);
        track.setMode("showing", event);
      } else if (track.mode === "showing") {
        track.setMode("disabled", event);
      }
    }
  }
};

// src/player/media/tracks/text/render/text-renderer.ts
var TextRenderers = class {
  constructor({ $store, $iosControls, textTracks }) {
    this._video = null;
    this._renderers = [];
    this._nativeDisplay = false;
    this._nativeRenderer = null;
    this._customRenderer = null;
    this._textTracks = textTracks;
    effect2(() => {
      this._nativeDisplay = $store.controls || $iosControls();
      this._update();
    });
    onDispose(this._detach.bind(this));
    listenEvent(textTracks, "add", (event) => this._addNativeTrack(event.detail));
    listenEvent(textTracks, "remove", (event) => this._removeNativeTrack(event.detail));
    listenEvent(textTracks, "mode-change", this._update.bind(this));
  }
  add(renderer) {
    this._renderers.push(renderer);
    this._update();
  }
  remove(renderer) {
    this._renderers.splice(this._renderers.indexOf(renderer), 1);
    this._update();
  }
  /* @internal */
  [ATTACH_VIDEO](video) {
    requestAnimationFrame(() => {
      this._video = video;
      if (video) {
        this._nativeRenderer = new NativeTextRenderer();
        this._nativeRenderer.attach(video);
        for (const track of this._textTracks)
          this._addNativeTrack(track);
      }
      this._update();
    });
  }
  _addNativeTrack(track) {
    if (!isTrackCaptionKind(track))
      return;
    this._nativeRenderer?.addTrack(track);
  }
  _removeNativeTrack(track) {
    if (!isTrackCaptionKind(track))
      return;
    this._nativeRenderer?.removeTrack(track);
  }
  _update() {
    if (!this._video) {
      this._detach();
      return;
    }
    const currentTrack = this._textTracks.selected;
    if (this._nativeDisplay || currentTrack?.[TEXT_TRACK_NATIVE_HLS]) {
      this._customRenderer?.changeTrack(null);
      this._nativeRenderer.setDisplay(true);
      this._nativeRenderer.changeTrack(currentTrack);
      return;
    }
    this._nativeRenderer.setDisplay(false);
    this._nativeRenderer.changeTrack(null);
    if (!currentTrack) {
      this._customRenderer?.changeTrack(null);
      return;
    }
    const customRenderer = this._renderers.sort((a, b) => a.priority - b.priority).find((loader) => loader.canRender(currentTrack));
    if (this._customRenderer !== customRenderer) {
      this._customRenderer?.detach();
      customRenderer?.attach(this._video);
      this._customRenderer = customRenderer ?? null;
    }
    customRenderer?.changeTrack(currentTrack);
  }
  _detach() {
    this._nativeRenderer?.detach();
    this._nativeRenderer = null;
    this._customRenderer?.detach();
    this._customRenderer = null;
  }
};

// src/player/media/tracks/text/text-tracks.ts
var TextTrackList = class extends List {
  constructor() {
    super(...arguments);
    this._canLoad = false;
    this._default = null;
    this._handleTrackModeChange = this._onTrackModeChange.bind(this);
  }
  get default() {
    return this._default;
  }
  get selected() {
    const track = this._items.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
    return track ?? null;
  }
  add(init2, trigger) {
    const isTrack = init2 instanceof TextTrack, track = isTrack ? init2 : new TextTrack(init2);
    if (this._default && init2.default)
      delete init2.default;
    track.addEventListener("mode-change", this._handleTrackModeChange);
    this[LIST_ADD](track, trigger);
    if (this._canLoad)
      track[TEXT_TRACK_CAN_LOAD]();
    if (init2.default) {
      this._default = track;
      track.mode = "showing";
    }
    return this;
  }
  remove(track, trigger) {
    if (!this._items.includes(track))
      return;
    if (track === this._default)
      this._default = null;
    track.mode = "disabled";
    track[TEXT_TRACK_ON_MODE_CHANGE] = null;
    track.removeEventListener("mode-change", this._handleTrackModeChange);
    this[LIST_REMOVE](track, trigger);
    return this;
  }
  clear(trigger) {
    for (const track of this._items)
      this.remove(track, trigger);
    return this;
  }
  getById(id) {
    return this._items.find((track) => track.id === id) ?? null;
  }
  getByKind(kind) {
    const kinds = Array.isArray(kind) ? kind : [kind];
    return this._items.filter((track) => kinds.includes(track.kind));
  }
  /* @internal */
  [TEXT_TRACK_CAN_LOAD]() {
    if (this._canLoad)
      return;
    for (const track of this._items)
      track[TEXT_TRACK_CAN_LOAD]();
    this._canLoad = true;
  }
  _onTrackModeChange(event) {
    const track = event.detail;
    if (track.mode === "showing") {
      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
      for (const t of this._items) {
        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
          t.mode = "disabled";
        }
      }
    }
    this.dispatchEvent(
      new DOMEvent("mode-change", {
        detail: event.detail,
        trigger: event
      })
    );
  }
};

// src/foundation/observers/intersection-observer.ts
function createIntersectionObserverAdapter($target, init2 = {}) {
  const $intersecting = signal(false), { skipInitial, callback, ...observerInit } = init2;
  let disconnect;
  effect2(() => {
    const target = $target();
    if (!target) {
      $intersecting.set(false);
      return;
    }
    let first = true;
    const observer = new IntersectionObserver((entries) => {
      if (first && skipInitial) {
        first = false;
        return;
      }
      callback?.(entries, observer);
      $intersecting.set(entries[0].isIntersecting);
    }, observerInit);
    observer.observe(target);
    return disconnect = () => {
      observer.disconnect();
      disconnect = void 0;
    };
  });
  return {
    get intersecting() {
      return $intersecting();
    },
    disconnect() {
      disconnect?.();
    }
  };
}

// src/player/media/controller/can-load.ts
function useMediaCanLoad($controller, $load, callback) {
  onConnect(async () => {
    const load = $load();
    if (load === "eager") {
      requestAnimationFrame(callback);
    } else if (load === "idle") {
      const { waitIdlePeriod } = await import('./chunks/std-BQBHX5BJ.js');
      waitIdlePeriod(callback);
    } else if (load === "visible") {
      root(async (dispose) => {
        const io = createIntersectionObserverAdapter($controller);
        effect2(() => {
          if (io.intersecting) {
            callback();
            dispose();
          }
        });
      });
    }
  });
}

// src/player/media/controller/controller-delegate.ts
function createMediaControllerDelegate({ $player, $store, logger }, handle) {
  const dispatch = (type, ...init2) => {
    handle(new DOMEvent(type, init2?.[0]));
  };
  async function ready(info, trigger) {
    if (peek(() => $store.canPlay))
      return;
    dispatch("can-play", { detail: info, trigger });
    tick();
    {
      logger?.infoGroup("-~-~-~-~-~-~-~-~- \u2705 MEDIA READY -~-~-~-~-~-~-~-~-").labelledLog("Media Store", { ...$store }).labelledLog("Trigger Event", trigger).dispatch();
    }
    if ($store.canPlay && $store.autoplay && !$store.started) {
      await attemptAutoplay();
    }
  }
  async function attemptAutoplay() {
    $store.attemptingAutoplay = true;
    try {
      await $player().play();
      dispatch("autoplay", { detail: { muted: $store.muted } });
    } catch (error) {
      dispatch("autoplay-fail", {
        detail: {
          muted: $store.muted,
          error
        }
      });
    } finally {
      $store.attemptingAutoplay = false;
    }
  }
  return {
    dispatch,
    ready
  };
}

// src/player/media/controller/events-logger.ts
var mediaEvents = [
  "abort",
  "can-play",
  "can-play-through",
  "duration-change",
  "emptied",
  "ended",
  "error",
  "fullscreen-change",
  "loaded-data",
  "loaded-metadata",
  "load-start",
  "media-type-change",
  "pause",
  "play",
  "playing",
  "progress",
  "seeked",
  "seeking",
  "source-change",
  "sources-change",
  "stalled",
  "started",
  "suspend",
  "stream-type-change",
  "replay",
  // 'time-update',
  "view-type-change",
  "volume-change",
  "waiting"
] ;
function useMediaEventsLogger({ $player, $store }, logger) {
  effect2(() => {
    const player = $player();
    if (player) {
      for (const eventType of mediaEvents) {
        listenEvent(player, eventType, (event) => {
          logger?.infoGroup(`\u{1F4E1} dispatching \`${eventType}\``).labelledLog("Media Store", { ...$store }).labelledLog("Event", event).dispatch();
        });
      }
    }
  });
}

// src/player/media/controller/prop-change.ts
function useMediaPropChange({ $player, $store }, {
  $autoplay,
  $poster,
  $loop,
  $controls,
  $crossorigin,
  $playsinline,
  $logLevel,
  $liveEdgeTolerance,
  $minLiveDVRWindow
}) {
  effect2(() => {
    const player = $player();
    if (!player)
      return;
    {
      effect2(() => {
        $store.logLevel = $logLevel();
      });
    }
    effect2(() => {
      const autoplay = $autoplay();
      $store.autoplay = autoplay;
      dispatchEvent(player, "autoplay-change", { detail: autoplay });
    });
    effect2(() => {
      const poster = $poster();
      $store.poster = poster;
      dispatchEvent(player, "poster-change", { detail: poster });
    });
    effect2(() => {
      const loop = $loop();
      $store.loop = loop;
      dispatchEvent(player, "loop-change", { detail: loop });
    });
    effect2(() => {
      const controls = $controls();
      $store.controls = controls;
      dispatchEvent(player, "controls-change", { detail: controls });
    });
    effect2(() => {
      $store.crossorigin = $crossorigin();
    });
    effect2(() => {
      const playsinline = $playsinline();
      $store.playsinline = playsinline;
      dispatchEvent(player, "playsinline-change", { detail: playsinline });
    });
    effect2(() => {
      $store.liveEdgeTolerance = $liveEdgeTolerance();
      $store.minLiveDVRWindow = $minLiveDVRWindow();
    });
    effect2(() => {
      dispatchEvent(player, "live-change", { detail: $store.live });
    });
    effect2(() => {
      dispatchEvent(player, "live-edge-change", { detail: $store.liveEdge });
    });
  });
}

// src/foundation/queue/request-queue.ts
var RequestQueue = class {
  constructor() {
    this._serving = false;
    this._pending = deferredPromise();
    this._queue = /* @__PURE__ */ new Map();
  }
  /**
   * The number of callbacks that are currently in queue.
   */
  get _size() {
    return this._queue.size;
  }
  /**
   * Whether items in the queue are being served immediately, otherwise they're queued to
   * be processed later.
   */
  get _isServing() {
    return this._serving;
  }
  /**
   * Waits for the queue to be flushed (ie: start serving).
   */
  async _waitForFlush() {
    if (this._serving)
      return;
    await this._pending.promise;
  }
  /**
   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
   * then the callback will be invoked immediately.
   *
   * @param key - Uniquely identifies this callback so duplicates are ignored.
   * @param callback - The function to call when this item in the queue is being served.
   */
  _enqueue(key2, callback) {
    if (this._serving) {
      callback();
      return;
    }
    this._queue.delete(key2);
    this._queue.set(key2, callback);
  }
  /**
   * Invokes the callback with the given `key` in the queue (if it exists).
   */
  _serve(key2) {
    this._queue.get(key2)?.();
    this._queue.delete(key2);
  }
  /**
   * Flush all queued items and start serving future requests immediately until `stop()` is called.
   */
  _start() {
    this._flush();
    this._serving = true;
    if (this._queue.size > 0)
      this._flush();
  }
  /**
   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
   */
  _stop() {
    this._serving = false;
  }
  /**
   * Stop serving requests, empty the request queue, and release any promises waiting for the
   * queue to flush.
   */
  _reset() {
    this._stop();
    this._queue.clear();
    this._release();
  }
  _flush() {
    for (const key2 of this._queue.keys())
      this._serve(key2);
    this._release();
  }
  _release() {
    this._pending.resolve();
    this._pending = deferredPromise();
  }
};

// src/player/media/controller/provider-delegate.ts
function useMediaProviderDelegate({ $provider, $store: $media }, requestManager, {
  $paused,
  $volume,
  $muted,
  $currentTime,
  $playsinline,
  $playbackRate
}) {
  const canPlayQueue = new RequestQueue();
  effect2(() => {
    if ($media.canPlay && $provider())
      canPlayQueue._start();
    else
      canPlayQueue._stop();
  });
  effect2(() => setMuted($muted()));
  effect2(() => setPaused($paused()));
  effect2(() => setVolume($volume()));
  effect2(() => setCurrentTime($currentTime()));
  effect2(() => setPlaysinline($playsinline()));
  effect2(() => setPlaybackRate($playbackRate()));
  function setPaused(paused) {
    if (paused)
      canPlayQueue._enqueue("paused", requestManager._pause);
    else
      canPlayQueue._enqueue("paused", requestManager._play);
  }
  function setVolume(volume) {
    const newVolume = clampNumber(0, volume, 1);
    canPlayQueue._enqueue("volume", () => $provider().volume = newVolume);
  }
  function setMuted(muted) {
    canPlayQueue._enqueue("muted", () => $provider().muted = muted);
  }
  function setCurrentTime(currentTime) {
    canPlayQueue._enqueue("currentTime", () => {
      const adapter = $provider();
      if (currentTime !== adapter.currentTime) {
        peek(() => {
          const boundTime = Math.min(
            Math.max($media.seekableStart + 0.1, currentTime),
            $media.seekableEnd - 0.1
          );
          if (Number.isFinite(boundTime))
            adapter.currentTime = boundTime;
        });
      }
    });
  }
  function setPlaysinline(playsinline) {
    canPlayQueue._enqueue("playsinline", () => $provider().playsinline = playsinline);
  }
  function setPlaybackRate(rate) {
    canPlayQueue._enqueue("rate", () => $provider().playbackRate = rate);
  }
  const delegate = {};
  const setters = {
    paused: setPaused,
    muted: setMuted,
    volume: setVolume,
    currentTime: setCurrentTime,
    playsinline: setPlaysinline,
    playbackRate: setPlaybackRate
  };
  for (const prop of Object.keys(setters)) {
    Object.defineProperty(delegate, prop, {
      get: () => $media[prop],
      set: setters[prop]
    });
  }
  return delegate;
}

// src/foundation/orientation/screen-orientation.ts
var CAN_ORIENT_SCREEN = canOrientScreen();
function createScreenOrientationAdapter($target) {
  const $orientation = signal(getScreenOrientation()), $locked = signal(false);
  let currentLock;
  if (CAN_ORIENT_SCREEN) {
    effect2(() => {
      const target = $target();
      if (!target)
        return;
      listenEvent(screen.orientation, "change", (trigger) => {
        const orientation = getScreenOrientation();
        $orientation.set(orientation);
        dispatchEvent(target, "orientation-change", {
          detail: { orientation, lock: currentLock },
          trigger
        });
      });
      return async () => {
        if (CAN_ORIENT_SCREEN && $locked())
          await unlock();
      };
    });
  }
  async function lock(lockType) {
    if (peek($locked))
      return;
    assertScreenOrientationAPI();
    await screen.orientation.lock(lockType);
    $locked.set(true);
    currentLock = lockType;
  }
  async function unlock() {
    if (!peek($locked))
      return;
    assertScreenOrientationAPI();
    currentLock = void 0;
    await screen.orientation.unlock();
    $locked.set(false);
  }
  return {
    get orientation() {
      return $orientation();
    },
    get locked() {
      return $locked();
    },
    get supported() {
      return CAN_ORIENT_SCREEN;
    },
    lock,
    unlock
  };
}
function assertScreenOrientationAPI() {
  if (!CAN_ORIENT_SCREEN)
    return;
  throw Error(
    "[vidstack] screen orientation API is not available" 
  );
}
function getScreenOrientation() {
  return window.screen?.orientation?.type;
}

// src/foundation/queue/queue.ts
var Queue = class {
  constructor() {
    this._queue = /* @__PURE__ */ new Map();
  }
  /**
   * Queue the given `item` under the given `key` to be processed at a later time by calling
   * `serve(key)`.
   */
  _enqueue(key2, item) {
    if (!this._queue.has(key2))
      this._queue.set(key2, /* @__PURE__ */ new Set());
    this._queue.get(key2).add(item);
  }
  /**
   * Process all items in queue for the given `key`.
   */
  _serve(key2, callback) {
    const items = this._queue.get(key2);
    if (items)
      for (const item of items)
        callback(item);
    this._queue.delete(key2);
  }
  /**
   * Removes all queued items under the given `key`.
   */
  _delete(key2) {
    this._queue.delete(key2);
  }
  /**
   * The number of items currently queued under the given `key`.
   */
  _size(key2) {
    return this._queue.get(key2)?.size ?? 0;
  }
  /**
   * Clear all items in the queue.
   */
  _reset() {
    this._queue.clear();
  }
};

// src/player/media/user.ts
var STOP_IDLE_EVENTS = ["pointerup", "pointermove", "focus", "keydown", "playing"];
function createMediaUser($controller, $media) {
  let idleTimeout, delay = 2e3, trigger, $idle = signal(false), $userPaused = signal(false), $paused = computed(() => $userPaused() || $media.paused);
  effect2(() => {
    const target = $controller();
    if (!target)
      return;
    effect2(() => {
      if ($paused())
        return;
      for (const eventType of STOP_IDLE_EVENTS) {
        listenEvent(target, eventType, stopIdling);
      }
    });
    effect2(() => {
      window.clearTimeout(idleTimeout);
      const idle = $idle() && !$paused();
      $media.userIdle = idle;
      dispatchEvent(target, "user-idle-change", { detail: idle, trigger });
      trigger = void 0;
    });
    return () => $idle.set(false);
  });
  function stopIdling(event) {
    if ($idle())
      trigger = event;
    $idle.set(false);
    window.clearTimeout(idleTimeout);
    idleTimeout = window.setTimeout(() => $idle.set(!peek($paused)), delay);
  }
  return {
    idle: {
      get idling() {
        return $idle();
      },
      get paused() {
        return $userPaused();
      },
      set paused(paused) {
        $userPaused.set(paused);
      },
      get delay() {
        return delay;
      },
      set delay(newDelay) {
        delay = newDelay;
      }
    }
  };
}

// src/player/media/controller/request-manager.ts
function createMediaRequestManager({ $player, $store: $media, $provider, logger, qualities, audioTracks, textTracks }, handler, requests, $props) {
  const user = createMediaUser($player, $media), orientation = createScreenOrientationAdapter($player), fullscreen = createFullscreenAdapter($player);
  effect2(() => {
    user.idle.delay = $props.$userIdleDelay();
  });
  effect2(() => {
    const supported = fullscreen.supported || $provider()?.fullscreen?.supported || false;
    if ($media.canLoad && peek(() => $media.canFullscreen) === supported)
      return;
    $media.canFullscreen = supported;
  });
  effect2(() => {
    const supported = $provider()?.pictureInPicture?.supported || false;
    if ($media.canLoad && peek(() => $media.canPictureInPicture) === supported)
      return;
    $media.canPictureInPicture = supported;
  });
  function logRequest(event) {
    {
      logger?.infoGroup(`\u{1F4EC} received \`${event.type}\``).labelledLog("Request", event).dispatch();
    }
  }
  const eventHandlers = {
    "media-audio-track-change-request": onAudioTrackChangeRequest,
    "media-enter-fullscreen-request": onEnterFullscreenRequest,
    "media-exit-fullscreen-request": onExitFullscreenRequest,
    "media-enter-pip-request": onEnterPictureInPictureRequest,
    "media-exit-pip-request": onExitPictureInPictureRequest,
    "media-hide-poster-request": onHidePosterRequest,
    "media-live-edge-request": onSeekToLiveEdgeRequest,
    "media-loop-request": onLoopRequest,
    "media-mute-request": onMuteRequest,
    "media-pause-request": onPauseRequest,
    "media-pause-user-idle-request": onPauseIdlingRequest,
    "media-play-request": onPlayRequest,
    "media-rate-change-request": onRateChangeRequest,
    "media-quality-change-request": onQualityChangeRequest,
    "media-resume-user-idle-request": onResumeIdlingRequest,
    "media-seek-request": onSeekRequest,
    "media-seeking-request": onSeekingRequest,
    "media-show-poster-request": onShowPosterRequest,
    "media-start-loading": onStartLoading,
    "media-text-track-change-request": onTextTrackChangeRequest,
    "media-unmute-request": onUnmuteRequest,
    "media-volume-change-request": onVolumeChangeRequest
  };
  effect2(() => {
    const target = $player();
    if (!target)
      return;
    for (const eventType of keysOf(eventHandlers)) {
      const handler2 = eventHandlers[eventType];
      listenEvent(target, eventType, (event) => {
        event.stopPropagation();
        logRequest(event);
        if (peek($provider))
          handler2(event);
      });
    }
  });
  function onStartLoading(event) {
    if ($media.canLoad)
      return;
    requests._queue._enqueue("load", event);
    handler.handle(createEvent($player, "can-load"));
  }
  function onMuteRequest(event) {
    if ($media.muted)
      return;
    requests._queue._enqueue("volume", event);
    $provider().muted = true;
  }
  function onUnmuteRequest(event) {
    if (!$media.muted)
      return;
    requests._queue._enqueue("volume", event);
    $provider().muted = false;
    if ($media.volume === 0) {
      requests._queue._enqueue("volume", event);
      $provider().volume = 0.25;
    }
  }
  function onRateChangeRequest(event) {
    if ($media.playbackRate === event.detail)
      return;
    requests._queue._enqueue("rate", event);
    $provider().playbackRate = event.detail;
  }
  function onTextTrackChangeRequest(event) {
    const { index, mode } = event.detail, track = textTracks[index];
    if (track) {
      requests._queue._enqueue("textTrack", event);
      track.setMode(mode, event);
    } else {
      logger?.warnGroup("[vidstack] failed text track change request (invalid index)").labelledLog("Text Tracks", textTracks.toArray()).labelledLog("Index", index).labelledLog("Event", event).dispatch();
    }
  }
  function onAudioTrackChangeRequest(event) {
    if (audioTracks.readonly) {
      {
        logger?.warnGroup(`[vidstack] attempted to change audio track but it is currently read-only`).labelledLog("Event", event).dispatch();
      }
      return;
    }
    const index = event.detail, track = audioTracks[index];
    if (track) {
      requests._queue._enqueue("audioTrack", event);
      track.selected = true;
    } else {
      logger?.warnGroup("[vidstack] failed audio track change request (invalid index)").labelledLog("Audio Tracks", audioTracks.toArray()).labelledLog("Index", index).labelledLog("Event", event).dispatch();
    }
  }
  function onQualityChangeRequest(event) {
    if (qualities.readonly) {
      {
        logger?.warnGroup(`[vidstack] attempted to change video quality but it is currently read-only`).labelledLog("Event", event).dispatch();
      }
      return;
    }
    requests._queue._enqueue("quality", event);
    const index = event.detail;
    if (index < 0) {
      qualities.autoSelect(event);
    } else {
      const quality = qualities[index];
      if (quality) {
        quality.selected = true;
      } else {
        logger?.warnGroup("[vidstack] failed quality change request (invalid index)").labelledLog("Qualities", qualities.toArray()).labelledLog("Index", index).labelledLog("Event", event).dispatch();
      }
    }
  }
  async function onPlayRequest(event) {
    if (!$media.paused)
      return;
    try {
      requests._queue._enqueue("play", event);
      await $provider().play();
    } catch (e) {
      const errorEvent = createEvent($player, "play-fail", { detail: coerceToError(e) });
      handler.handle(errorEvent);
    }
  }
  async function onPauseRequest(event) {
    if ($media.paused)
      return;
    try {
      requests._queue._enqueue("pause", event);
      await $provider().pause();
    } catch (e) {
      requests._queue._delete("pause");
      logger?.error("pause-fail", e);
    }
  }
  function onSeekingRequest(event) {
    requests._queue._enqueue("seeking", event);
    $media.seeking = true;
    requests._$isSeeking.set(true);
  }
  function onSeekRequest(event) {
    if ($media.ended)
      requests._$isReplay.set(true);
    requests._$isSeeking.set(false);
    requests._queue._delete("seeking");
    const boundTime = Math.min(
      Math.max($media.seekableStart + 0.1, event.detail),
      $media.seekableEnd - 0.1
    );
    if (!Number.isFinite(boundTime) || !$media.canSeek)
      return;
    requests._queue._enqueue("seeked", event);
    $provider().currentTime = boundTime;
    if ($media.live && event.isOriginTrusted && Math.abs($media.seekableEnd - boundTime) >= 2) {
      $media.userBehindLiveEdge = true;
    }
  }
  function onSeekToLiveEdgeRequest(event) {
    if (!$media.live || $media.liveEdge || !$media.canSeek)
      return;
    requests._queue._enqueue("seeked", event);
    try {
      seekToLiveEdge();
    } catch (e) {
      logger?.error("seek to live edge fail", e);
    }
  }
  function onVolumeChangeRequest(event) {
    const volume = event.detail;
    if ($media.volume === volume)
      return;
    requests._queue._enqueue("volume", event);
    $provider().volume = volume;
    if (volume > 0 && $media.muted) {
      requests._queue._enqueue("volume", event);
      $provider().muted = false;
    }
  }
  async function onEnterFullscreenRequest(event) {
    try {
      requests._queue._enqueue("fullscreen", event);
      await enterFullscreen(event.detail);
    } catch (error) {
      onFullscreenError(error);
    }
  }
  async function onExitFullscreenRequest(event) {
    try {
      requests._queue._enqueue("fullscreen", event);
      await exitFullscreen2(event.detail);
    } catch (error) {
      onFullscreenError(error);
    }
  }
  function onFullscreenError(error) {
    handler.handle(createEvent($player, "fullscreen-error", { detail: coerceToError(error) }));
  }
  async function onEnterPictureInPictureRequest(event) {
    try {
      requests._queue._enqueue("pip", event);
      await enterPictureInPicture();
    } catch (error) {
      onPictureInPictureError(error);
    }
  }
  async function onExitPictureInPictureRequest(event) {
    try {
      requests._queue._enqueue("pip", event);
      await exitPictureInPicture();
    } catch (error) {
      onPictureInPictureError(error);
    }
  }
  function onPictureInPictureError(error) {
    handler.handle(
      createEvent($player, "picture-in-picture-error", {
        detail: coerceToError(error)
      })
    );
  }
  function onResumeIdlingRequest(event) {
    requests._queue._enqueue("userIdle", event);
    user.idle.paused = false;
  }
  function onPauseIdlingRequest(event) {
    requests._queue._enqueue("userIdle", event);
    user.idle.paused = true;
  }
  function onShowPosterRequest(event) {
    $media.canLoadPoster = true;
  }
  function onHidePosterRequest(event) {
    $media.canLoadPoster = false;
  }
  function onLoopRequest(event) {
    window.requestAnimationFrame(async () => {
      try {
        requests._$isLooping.set(true);
        requests._$isReplay.set(true);
        await play();
      } catch (e) {
        requests._$isLooping.set(false);
        requests._$isReplay.set(false);
      }
    });
  }
  function throwIfFullscreenNotSupported(target, fullscreen2) {
    if (fullscreen2?.supported)
      return;
    throw Error(
      `[vidstack] fullscreen is not currently available on target \`${target}\`` 
    );
  }
  async function play() {
    if (!$media.paused)
      return;
    try {
      const provider = peek($provider);
      throwIfNotReadyForPlayback(provider, $player);
      if (peek(() => $media.ended))
        provider.currentTime = $media.seekableStart + 0.1;
      return provider.play();
    } catch (error) {
      const errorEvent = createEvent($player, "play-fail", { detail: coerceToError(error) });
      errorEvent.autoplay = $media.attemptingAutoplay;
      handler.handle(errorEvent);
      throw error;
    }
  }
  async function pause() {
    if ($media.paused)
      return;
    const provider = peek($provider);
    throwIfNotReadyForPlayback(provider, $player);
    return provider.pause();
  }
  let wasPictureInPictureActive = false;
  async function enterFullscreen(target = "prefer-media") {
    const provider = peek($provider), adapter = target === "prefer-media" && fullscreen.supported || target === "media" ? fullscreen : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, adapter);
    if (adapter.active)
      return;
    if ($media.pictureInPicture) {
      wasPictureInPictureActive = true;
      await exitPictureInPicture();
    }
    const lockType = peek($props.$fullscreenOrientation);
    if (orientation.supported && !isUndefined(lockType))
      await orientation.lock(lockType);
    return adapter.enter();
  }
  async function exitFullscreen2(target = "prefer-media") {
    const provider = peek($provider), adapter = target === "prefer-media" && fullscreen.supported || target === "media" ? fullscreen : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, adapter);
    if (!adapter.active)
      return;
    if (orientation.locked)
      await orientation.unlock();
    try {
      const result = await adapter.exit();
      if (wasPictureInPictureActive && $media.canPictureInPicture) {
        await enterPictureInPicture();
      }
      return result;
    } finally {
      wasPictureInPictureActive = false;
    }
  }
  function throwIfPictureInPictureNotSupported() {
    if ($media.canPictureInPicture)
      return;
    throw Error(
      `[vidstack] picture-in-picture is not currently available` 
    );
  }
  async function enterPictureInPicture() {
    throwIfPictureInPictureNotSupported();
    if ($media.pictureInPicture)
      return;
    return await $provider().pictureInPicture.enter();
  }
  async function exitPictureInPicture() {
    throwIfPictureInPictureNotSupported();
    if (!$media.pictureInPicture)
      return;
    return await $provider().pictureInPicture.exit();
  }
  function seekToLiveEdge() {
    $media.userBehindLiveEdge = false;
    if (peek(() => !$media.live || $media.liveEdge || !$media.canSeek))
      return;
    const provider = peek($provider);
    throwIfNotReadyForPlayback(provider, $player);
    provider.currentTime = $media.liveSyncPosition ?? $media.seekableEnd - 2;
  }
  return {
    _user: user,
    _orientation: orientation,
    _play: play,
    _pause: pause,
    _enterFullscreen: enterFullscreen,
    _exitFullscreen: exitFullscreen2,
    _enterPictureInPicture: enterPictureInPicture,
    _exitPictureInPicture: exitPictureInPicture,
    _seekToLiveEdge: seekToLiveEdge
  };
}
function throwIfNotReadyForPlayback(provider, $player) {
  if (provider && peek(() => $player()?.state.canPlay))
    return;
  throw Error(
    `[vidstack] media is not ready - wait for \`can-play\` event.` 
  );
}
var MediaRequestContext = class {
  constructor() {
    this._queue = new Queue();
    this._$isSeeking = signal(false);
    this._$isLooping = signal(false);
    this._$isReplay = signal(false);
  }
};

// ../../node_modules/.pnpm/just-debounce-it@3.2.0/node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce;
function debounce(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}

// ../../node_modules/.pnpm/just-throttle@4.2.0/node_modules/just-throttle/index.mjs
var functionThrottle = throttle;
function throttle(fn, interval, options) {
  var timeoutId = null;
  var throttledFn = null;
  var leading = options && options.leading;
  var trailing = options && options.trailing;
  if (leading == null) {
    leading = true;
  }
  if (trailing == null) {
    trailing = !leading;
  }
  if (leading == true) {
    trailing = false;
  }
  var cancel = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  var flush = function() {
    var call = throttledFn;
    cancel();
    if (call) {
      call();
    }
  };
  var throttleWrapper = function() {
    var callNow = leading && !timeoutId;
    var context = this;
    var args = arguments;
    throttledFn = function() {
      return fn.apply(context, args);
    };
    if (!timeoutId) {
      timeoutId = setTimeout(function() {
        timeoutId = null;
        if (trailing) {
          return throttledFn();
        }
      }, interval);
    }
    if (callNow) {
      callNow = false;
      return throttledFn();
    }
  };
  throttleWrapper.cancel = cancel;
  throttleWrapper.flush = flush;
  return throttleWrapper;
}

// src/player/media/controller/state-manager.ts
var trackedEventType = /* @__PURE__ */ new Set([
  "autoplay",
  "autoplay-fail",
  "can-load",
  "sources-change",
  "source-change",
  "load-start",
  "abort",
  "error",
  "loaded-metadata",
  "loaded-data",
  "can-play",
  "play",
  "play-fail",
  "pause",
  "playing",
  "seeking",
  "seeked",
  "waiting"
]);
function createMediaStateManager({
  $player,
  $loader,
  $provider,
  $store: $media,
  qualities,
  audioTracks,
  textTracks,
  logger
}, requests) {
  useDisposalBin(); const trackedEvents = /* @__PURE__ */ new Map();
  let skipInitialSrcChange = true, fireWaitingEvent, firingWaiting = false, waitingTriggerEvent;
  onAttach(() => {
    $player()?.setAttribute("aria-busy", "true");
  });
  effect2(() => {
    const target = $player();
    if (!target)
      return;
    addTextTrackListeners();
    addQualityListeners();
    addAudioTrackListeners();
    listenEvent(target, "fullscreen-change", onFullscreenChange);
    listenEvent(target, "fullscreen-error", onFullscreenError);
  });
  function addTextTrackListeners() {
    onTextTracksChange();
    onTextTrackChange();
    listenEvent(textTracks, "add", onTextTracksChange);
    listenEvent(textTracks, "remove", onTextTracksChange);
    listenEvent(textTracks, "mode-change", onTextTrackChange);
  }
  function addAudioTrackListeners() {
    listenEvent(audioTracks, "add", onAudioTracksChange);
    listenEvent(audioTracks, "remove", onAudioTracksChange);
    listenEvent(audioTracks, "change", onAudioTrackChange);
  }
  function addQualityListeners() {
    listenEvent(qualities, "add", onQualitiesChange);
    listenEvent(qualities, "remove", onQualitiesChange);
    listenEvent(qualities, "change", onQualityChange);
    listenEvent(qualities, "auto-change", onAutoQualityChange);
    listenEvent(qualities, "readonly-change", onCanSetQualityChange);
  }
  const eventHandlers = {
    "provider-loader-change": onProviderLoaderChange,
    "provider-change": onProviderChange,
    autoplay: onAutoplay,
    "autoplay-fail": onAutoplayFail,
    "can-load": onCanLoad,
    "can-play-through": onCanPlayThrough,
    "can-play": onCanPlay,
    "duration-change": onDurationChange,
    "load-start": onLoadStart,
    "loaded-data": onLoadedData,
    "loaded-metadata": onLoadedMetadata,
    "media-type-change": onMediaTypeChange,
    "stream-type-change": onStreamTypeChange,
    "play-fail": onPlayFail,
    "rate-change": onRateChange,
    "source-change": onSourceChange,
    "sources-change": onSourcesChange,
    "time-update": onTimeUpdate,
    "volume-change": onVolumeChange,
    "fullscreen-change": onFullscreenChange,
    "fullscreen-error": onFullscreenError,
    "picture-in-picture-change": onPictureInPictureChange,
    "picture-in-picture-error": onPictureInPictureError,
    abort: onAbort,
    ended: onEnded,
    error: onError,
    pause: onPause,
    play: onPlay,
    playing: onPlaying,
    progress: onProgress,
    seeked: onSeeked,
    seeking: functionThrottle(onSeeking, 150, { leading: true }),
    waiting: onWaiting
  };
  function resetTracking() {
    stopWaiting();
    requests._$isReplay.set(false);
    requests._$isLooping.set(false);
    firingWaiting = false;
    waitingTriggerEvent = void 0;
    trackedEvents.clear();
  }
  function onProviderLoaderChange(event) {
    $loader.set(event.detail);
  }
  function onProviderChange(event) {
    $provider.set(event.detail);
  }
  function onMediaTypeChange(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
    const viewType = $media.viewType;
    $media.mediaType = event.detail;
    if (viewType !== $media.viewType) {
      setTimeout(
        () => $player()?.dispatchEvent(
          createEvent($player, "view-type-change", {
            detail: $media.viewType,
            trigger: event
          })
        ),
        0
      );
    }
  }
  function onStreamTypeChange(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
    $media.inferredStreamType = event.detail;
    event.detail = $media.streamType;
  }
  function onCanLoad(event) {
    $media.canLoad = true;
    trackedEvents.set("can-load", event);
    satisfyMediaRequest("load", event);
  }
  function onRateChange(event) {
    $media.playbackRate = event.detail;
    satisfyMediaRequest("rate", event);
  }
  function onTextTracksChange(event) {
    $media.textTracks = textTracks.toArray();
    dispatchEvent($player(), "text-tracks-change", {
      detail: $media.textTracks,
      trigger: event
    });
  }
  function onTextTrackChange(event) {
    satisfyMediaRequest("textTrack", event);
    const current = textTracks.selected;
    if ($media.textTrack !== current) {
      $media.textTrack = current;
      dispatchEvent($player(), "text-track-change", {
        detail: current,
        trigger: event
      });
    }
  }
  function onAudioTracksChange(event) {
    $media.audioTracks = audioTracks.toArray();
    dispatchEvent($player(), "audio-tracks-change", {
      detail: $media.audioTracks,
      trigger: event
    });
  }
  function onAudioTrackChange(event) {
    $media.audioTrack = audioTracks.selected;
    satisfyMediaRequest("audioTrack", event);
    dispatchEvent($player(), "audio-track-change", {
      detail: $media.audioTrack,
      trigger: event
    });
  }
  function onQualitiesChange(event) {
    $media.qualities = qualities.toArray();
    dispatchEvent($player(), "qualities-change", {
      detail: $media.qualities,
      trigger: event
    });
  }
  function onQualityChange(event) {
    $media.quality = qualities.selected;
    satisfyMediaRequest("quality", event);
    dispatchEvent($player(), "quality-change", {
      detail: $media.quality,
      trigger: event
    });
  }
  function onAutoQualityChange() {
    $media.autoQuality = qualities.auto;
  }
  function onCanSetQualityChange() {
    $media.canSetQuality = !qualities.readonly;
  }
  function onSourcesChange(event) {
    $media.sources = event.detail;
  }
  function onSourceChange(event) {
    appendTriggerEvent(event, trackedEvents.get("sources-change"));
    $media.source = event.detail;
    $player()?.setAttribute("aria-busy", "true");
    {
      logger?.infoGroup("\u{1F4FC} Media source change").labelledLog("Source", event.detail).dispatch();
    }
    if (skipInitialSrcChange) {
      skipInitialSrcChange = false;
      return;
    }
    audioTracks[LIST_RESET](event);
    qualities[LIST_RESET](event);
    resetTracking();
    softResetMediaStore($media);
    trackedEvents.set(event.type, event);
  }
  function onAbort(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
    appendTriggerEvent(event, trackedEvents.get("can-load"));
  }
  function onLoadStart(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
  }
  function onError(event) {
    $media.error = event.detail;
    appendTriggerEvent(event, trackedEvents.get("abort"));
  }
  function onLoadedMetadata(event) {
    appendTriggerEvent(event, trackedEvents.get("load-start"));
  }
  function onLoadedData(event) {
    appendTriggerEvent(event, trackedEvents.get("load-start"));
  }
  function onCanPlay(event) {
    if (event.trigger?.type !== "loadedmetadata") {
      appendTriggerEvent(event, trackedEvents.get("loaded-metadata"));
    }
    onCanPlayDetail(event.detail);
    $player()?.setAttribute("aria-busy", "false");
  }
  function onCanPlayThrough(event) {
    onCanPlayDetail(event.detail);
    appendTriggerEvent(event, trackedEvents.get("can-play"));
  }
  function onCanPlayDetail({ buffered, seekable }) {
    $media.seekable = seekable;
    $media.buffered = buffered;
    $media.duration = $media.seekableEnd;
    $media.canPlay = true;
  }
  function onDurationChange(event) {
    const duration = event.detail;
    if (!$media.live)
      $media.duration = !Number.isNaN(duration) ? duration : 0;
  }
  function onProgress(event) {
    const { buffered, seekable } = event.detail;
    $media.buffered = buffered;
    $media.seekable = seekable;
    if ($media.live) {
      $media.duration = $media.seekableEnd;
      dispatchEvent($player(), "duration-change", {
        detail: $media.seekableEnd,
        trigger: event
      });
    }
  }
  function onAutoplay(event) {
    appendTriggerEvent(event, trackedEvents.get("play"));
    appendTriggerEvent(event, trackedEvents.get("can-play"));
    $media.autoplayError = void 0;
  }
  function onAutoplayFail(event) {
    appendTriggerEvent(event, trackedEvents.get("play-fail"));
    appendTriggerEvent(event, trackedEvents.get("can-play"));
    $media.autoplayError = event.detail;
    resetTracking();
  }
  function onPlay(event) {
    event.autoplay = $media.attemptingAutoplay;
    if (requests._$isLooping() || !$media.paused) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, trackedEvents.get("waiting"));
    satisfyMediaRequest("play", event);
    $media.paused = false;
    $media.autoplayError = void 0;
    if ($media.ended || requests._$isReplay()) {
      requests._$isReplay.set(false);
      $media.ended = false;
      handleMediaEvent(createEvent($player, "replay", { trigger: event }));
    }
  }
  function onPlayFail(event) {
    appendTriggerEvent(event, trackedEvents.get("play"));
    satisfyMediaRequest("play", event);
    $media.paused = true;
    $media.playing = false;
    resetTracking();
  }
  function onPlaying(event) {
    const playEvent = trackedEvents.get("play");
    if (playEvent) {
      appendTriggerEvent(event, trackedEvents.get("waiting"));
      appendTriggerEvent(event, playEvent);
    } else {
      appendTriggerEvent(event, trackedEvents.get("seeked"));
    }
    setTimeout(() => resetTracking(), 0);
    $media.paused = false;
    $media.playing = true;
    $media.seeking = false;
    $media.ended = false;
    if (requests._$isLooping()) {
      event.stopImmediatePropagation();
      requests._$isLooping.set(false);
      return;
    }
    onStarted(event);
  }
  function onStarted(event) {
    if (!$media.started) {
      if ($media.live) {
        const end = $media.liveSyncPosition ?? $media.seekableEnd - 2;
        if (Number.isFinite(end))
          $provider().currentTime = end;
      }
      $media.started = true;
      handleMediaEvent(createEvent($player, "started", { trigger: event }));
    }
  }
  function onPause(event) {
    if (requests._$isLooping()) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, trackedEvents.get("seeked"));
    satisfyMediaRequest("pause", event);
    $media.paused = true;
    $media.playing = false;
    $media.seeking = false;
    resetTracking();
  }
  function onTimeUpdate(event) {
    const { currentTime, played } = event.detail;
    $media.currentTime = currentTime;
    $media.played = played;
    $media.waiting = false;
    for (const track of textTracks) {
      if (track.mode === "disabled")
        continue;
      track[TEXT_TRACK_UPDATE_ACTIVE_CUES](currentTime, event);
    }
  }
  function onVolumeChange(event) {
    $media.volume = event.detail.volume;
    $media.muted = event.detail.muted || event.detail.volume === 0;
    satisfyMediaRequest("volume", event);
  }
  function onSeeking(event) {
    $media.seeking = true;
    $media.currentTime = event.detail;
    satisfyMediaRequest("seeking", event);
    if ($media.paused) {
      waitingTriggerEvent = event;
      fireWaitingEvent();
    }
  }
  function onSeeked(event) {
    if (requests._$isSeeking()) {
      $media.seeking = true;
      event.stopImmediatePropagation();
    } else if ($media.seeking) {
      const waitingEvent = trackedEvents.get("waiting");
      appendTriggerEvent(event, waitingEvent);
      if (waitingEvent?.trigger?.type !== "seeking") {
        appendTriggerEvent(event, trackedEvents.get("seeking"));
      }
      if ($media.paused)
        stopWaiting();
      $media.seeking = false;
      if (event.detail !== $media.duration)
        $media.ended = false;
      $media.currentTime = event.detail;
      satisfyMediaRequest("seeked", event);
      const origin = event.originEvent;
      if (origin && origin.isTrusted && !/seek/.test(origin.type)) {
        onStarted(event);
      }
    }
  }
  fireWaitingEvent = functionDebounce(() => {
    if (!waitingTriggerEvent)
      return;
    firingWaiting = true;
    $media.waiting = true;
    $media.playing = false;
    const event = createEvent($player, "waiting", {
      trigger: waitingTriggerEvent
    });
    trackedEvents.set("waiting", event);
    $player()?.dispatchEvent(event);
    waitingTriggerEvent = void 0;
    firingWaiting = false;
  }, 300);
  function onWaiting(event) {
    if (firingWaiting || requests._$isSeeking())
      return;
    event.stopImmediatePropagation();
    waitingTriggerEvent = event;
    fireWaitingEvent();
  }
  function onEnded(event) {
    if (requests._$isLooping()) {
      event.stopImmediatePropagation();
      return;
    }
    $media.paused = true;
    $media.playing = false;
    $media.seeking = false;
    $media.ended = true;
    resetTracking();
  }
  function stopWaiting() {
    fireWaitingEvent?.cancel();
    $media.waiting = false;
  }
  function onFullscreenChange(event) {
    $media.fullscreen = event.detail;
    satisfyMediaRequest("fullscreen", event);
  }
  function onFullscreenError(event) {
    satisfyMediaRequest("fullscreen", event);
  }
  function onPictureInPictureChange(event) {
    $media.pictureInPicture = event.detail;
    satisfyMediaRequest("pip", event);
  }
  function onPictureInPictureError(event) {
    satisfyMediaRequest("pip", event);
  }
  function satisfyMediaRequest(request, event) {
    requests._queue._serve(request, (requestEvent) => {
      event.request = requestEvent;
      appendTriggerEvent(event, requestEvent);
    });
  }
  function handleMediaEvent(event) {
    eventHandlers[event.type]?.(event);
    if (trackedEventType.has(event.type)) {
      trackedEvents.set(event.type, event);
    }
    $player()?.dispatchEvent(event);
  }
  return { handle: handleMediaEvent };
}

// src/player/media/controller/create-controller.ts
function createMediaController(props) {
  const context = {
    $player: signal(null),
    $loader: signal(null),
    $provider: signal(null),
    $store: mediaStore.create(),
    qualities: new VideoQualityList(),
    audioTracks: new AudioTrackList(),
    $$props: {
      $src: props.$src,
      $textTracks: props.$textTracks,
      $preferNativeHLS: props.$preferNativeHLS
    }
  };
  provideContext(mediaContext, context);
  context.logger = useLogger(context.$player);
  context.remote = new MediaRemoteControl(context.logger );
  const $store = context.$store;
  context.$iosControls = computed(
    () => !canFullscreen() && $store.mediaType === "video" && ($store.controls && !props.$playsinline() || $store.fullscreen)
  );
  context.textTracks = new TextTrackList();
  context.textRenderers = new TextRenderers(context);
  const stop = effect2(() => {
    if (!context.$store.canLoad)
      return;
    context.textTracks[TEXT_TRACK_CAN_LOAD]();
    stop();
  });
  const requests = new MediaRequestContext(), stateManager = createMediaStateManager(context, requests), requestManager = createMediaRequestManager(context, stateManager, requests, props), delegate = createMediaControllerDelegate(context, stateManager.handle), providerDelegate = useMediaProviderDelegate(context, requestManager, props);
  context.delegate = delegate;
  const providedProps = {
    viewType: "providedViewType",
    streamType: "providedStreamType"
  };
  for (const prop of Object.keys(props)) {
    const propName = prop.slice(1);
    if (propName in $store)
      $store[providedProps[propName] ?? propName] = props[prop]();
  }
  effect2(() => {
    $store.providedViewType = props.$viewType();
    $store.providedStreamType = props.$streamType();
  });
  $store.muted = props.$muted() || props.$volume() === 0;
  useMediaPropChange(context, props);
  useMediaCanLoad(context.$player, props.$load, startLoadingMedia);
  useMediaEventsLogger(context, context.logger);
  function startLoadingMedia() {
    delegate.dispatch("can-load");
  }
  return {
    _context: context,
    _start: startLoadingMedia,
    _request: requestManager,
    _provider: providerDelegate
  };
}

// src/player/media/providers/type-check.ts
function isHTMLAudioElement(element) {
  return element instanceof HTMLAudioElement;
}
function isHTMLVideoElement(element) {
  return element instanceof HTMLVideoElement;
}
function isHTMLMediaElement(element) {
  return isHTMLAudioElement(element) || isHTMLVideoElement(element);
}

// src/player/element/keyboard.ts
var MEDIA_KEY_SHORTCUTS = {
  togglePaused: "k Space",
  toggleMuted: "m",
  toggleFullscreen: "f",
  togglePictureInPicture: "i",
  toggleCaptions: "c",
  seekBackward: "ArrowLeft",
  seekForward: "ArrowRight",
  volumeUp: "ArrowUp",
  volumeDown: "ArrowDown"
};
var MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Control"]);
var BUTTON_SELECTORS = 'button, [role="button"]';
var IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"]';
function useKeyboard({ $player, $store: $media, ariaKeys, remote }, { $keyShortcuts, $keyDisabled, $keyTarget }) {
  effect2(() => {
    const player = $player();
    if (!player || $keyDisabled())
      return;
    const target = $keyTarget() === "player" ? player : document, $active = signal(false);
    if (target === player) {
      listenEvent(player, "focusin", () => $active.set(true));
      listenEvent(player, "focusout", (event) => {
        if (!player.contains(event.target))
          $active.set(false);
      });
    } else {
      if (!peek($active)) {
        $active.set(document.querySelector("media-player") === player);
      }
      listenEvent(document, "focusin", (event) => {
        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
        if (activePlayer !== void 0)
          $active.set(player === activePlayer);
      });
    }
    function onPreventVideoKeys(event) {
      if (isHTMLMediaElement(event.target) && getMatchingMethod(event)) {
        event.preventDefault();
      }
    }
    effect2(() => {
      if (!$active())
        return;
      listenEvent(target, "keyup", onKeyUp);
      listenEvent(target, "keydown", onKeyDown);
      listenEvent(target, "keydown", onPreventVideoKeys, { capture: true });
    });
    let seekTotal;
    function calcSeekAmount(event, type) {
      const seekBy = event.shiftKey ? 10 : 5;
      return seekTotal = Math.max(
        0,
        Math.min(
          (seekTotal ?? $media.currentTime) + (type === "seekForward" ? +seekBy : -seekBy),
          $media.duration
        )
      );
    }
    let timeSlider = null;
    function forwardTimeKeyEvent(event) {
      timeSlider?.dispatchEvent(new DOMEvent(event.type, { trigger: event }));
    }
    function seeking(event, type) {
      if (!$media.canSeek)
        return;
      if (!timeSlider)
        timeSlider = player.querySelector("media-time-slider");
      if (timeSlider) {
        forwardTimeKeyEvent(event);
      } else {
        remote.seeking(calcSeekAmount(event, type), event);
      }
    }
    function onKeyUp(event) {
      const focused = document.activeElement, sliderFocused = focused?.hasAttribute("data-media-slider");
      if (!event.key || !$media.canSeek || sliderFocused || focused?.matches(IGNORE_SELECTORS)) {
        return;
      }
      const method = getMatchingMethod(event);
      if (method?.startsWith("seek")) {
        event.preventDefault();
        event.stopPropagation();
        if (timeSlider) {
          forwardTimeKeyEvent(event);
          timeSlider = null;
        } else {
          remote.seek(seekTotal, event);
          seekTotal = null;
        }
      }
      if (method?.startsWith("volume")) {
        const volumeSlider = player.querySelector("media-volume-slider");
        volumeSlider?.dispatchEvent(new DOMEvent("keyup", { trigger: event }));
      }
    }
    function onKeyDown(event) {
      if (!event.key || MODIFIER_KEYS.has(event.key))
        return;
      const focused = document.activeElement;
      if (focused?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focused?.matches(BUTTON_SELECTORS)) {
        return;
      }
      const sliderFocused = focused?.hasAttribute("data-media-slider"), method = getMatchingMethod(event);
      if (!method && /[0-9]/.test(event.key) && !sliderFocused) {
        event.preventDefault();
        event.stopPropagation();
        remote.seek($media.duration / 10 * Number(event.key), event);
        return;
      }
      if (!method || /volume|seek/.test(method) && sliderFocused)
        return;
      event.preventDefault();
      event.stopPropagation();
      switch (method) {
        case "seekForward":
        case "seekBackward":
          seeking(event, method);
          break;
        case "volumeUp":
        case "volumeDown":
          const volumeSlider = player.querySelector("media-volume-slider");
          if (volumeSlider) {
            volumeSlider.dispatchEvent(new DOMEvent("keydown", { trigger: event }));
          } else {
            const value = event.shiftKey ? 0.1 : 0.05;
            remote.changeVolume($media.volume + (method === "volumeUp" ? +value : -value), event);
          }
          break;
        case "toggleFullscreen":
          remote.toggleFullscreen("prefer-media", event);
          break;
        default:
          remote[method]?.(event);
      }
    }
    function getMatchingMethod(event) {
      const keyShortcuts = { ...$keyShortcuts(), ...ariaKeys };
      return Object.keys(keyShortcuts).find(
        (method) => keyShortcuts[method].split(" ").some(
          (keys) => replaceSymbolKeys(keys).replace(/Control/g, "Ctrl").split("+").every(
            (key2) => MODIFIER_KEYS.has(key2) ? event[key2.toLowerCase() + "Key"] : event.key === key2.replace("Space", " ")
          )
        )
      );
    }
  });
}
function useARIAKeyShortcuts(host, shortcut) {
  onAttach(() => {
    const { $keyShortcuts, ariaKeys } = useMedia(), keys = host.el.getAttribute("aria-keyshortcuts");
    if (keys) {
      ariaKeys[shortcut] = keys;
      {
        onDispose(() => {
          delete ariaKeys[shortcut];
        });
      }
      return;
    }
    const shortcuts = $keyShortcuts()[shortcut];
    if (shortcuts)
      host.el.setAttribute("aria-keyshortcuts", shortcuts);
  });
}
var SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
function replaceSymbolKeys(key2) {
  return key2.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
}

// src/player/element/props.ts
var mediaPlayerProps = {
  autoplay: { initial: false },
  aspectRatio: {
    initial: null,
    type: {
      from(value) {
        if (!value)
          return null;
        const [width, height] = value.split("/").map(Number);
        return +(width / height).toFixed(4);
      }
    }
  },
  controls: { initial: false },
  currentTime: { initial: 0 },
  crossorigin: {
    initial: null,
    // Needs to be fixed in Maverick.
    type: STRING
  },
  fullscreenOrientation: {},
  load: { initial: "visible" },
  logLevel: { initial: "silent" },
  loop: { initial: false },
  muted: { initial: false },
  paused: { initial: true },
  playsinline: { initial: false },
  playbackRate: { initial: 1 },
  poster: { initial: "" },
  preload: { initial: "metadata" },
  preferNativeHLS: {
    initial: false,
    attribute: "prefer-native-hls"
  },
  src: { initial: "" },
  userIdleDelay: { initial: 2e3 },
  viewType: { initial: "unknown" },
  streamType: { initial: "unknown" },
  volume: { initial: 1 },
  liveEdgeTolerance: { initial: 10 },
  minLiveDVRWindow: { initial: 60 },
  keyDisabled: { initial: false },
  keyTarget: { initial: "player" },
  keyShortcuts: { initial: MEDIA_KEY_SHORTCUTS },
  textTracks: { initial: [] }
};

// src/player/element/element.ts
var MEDIA_ATTRIBUTES = [
  "autoplay",
  "autoplayError",
  "canFullscreen",
  "canPictureInPicture",
  "canLoad",
  "canPlay",
  "canSeek",
  "ended",
  "error",
  "fullscreen",
  "loop",
  "live",
  "liveEdge",
  "mediaType",
  "muted",
  "paused",
  "pictureInPicture",
  "playing",
  "playsinline",
  "seeking",
  "started",
  "streamType",
  "userIdle",
  "viewType",
  "waiting"
];
var PlayerDefinition = defineCustomElement({
  tagName: "media-player",
  props: mediaPlayerProps,
  setup({ host, props, accessors }) {
    const scope = getScope(), controller = createMediaController(props), context = controller._context, $media = context.$store;
    {
      const logPrinter = createLogPrinter(host.$el);
      effect2(() => void (logPrinter.logLevel = props.$logLevel()));
    }
    onAttach(() => {
      host.el.setAttribute("tabindex", "0");
      if (!host.el.hasAttribute("aria-label")) {
        host.el.setAttribute("aria-label", "Media Player");
      }
      context.$player.set(host.el);
      context.remote.setTarget(host.el);
      context.remote.setPlayer(host.el);
      listenEvent(host.el, "find-media-player", ({ detail }) => detail(host.el));
    });
    onConnect(() => {
      dispatchEvent(host.el, "media-player-connect", {
        detail: host.el,
        bubbles: true,
        composed: true
      });
      window.requestAnimationFrame(() => {
        if (isNull($media.canLoadPoster))
          $media.canLoadPoster = true;
      });
    });
    context.ariaKeys = {};
    context.$keyShortcuts = props.$keyShortcuts;
    useKeyboard(context, props);
    useFocusVisible(host.$el);
    const $attrs = {
      "aspect-ratio": props.$aspectRatio,
      "data-captions": () => !!$media.textTrack && isTrackCaptionKind($media.textTrack),
      "data-ios-controls": context.$iosControls
    };
    const mediaAttrName = {
      canPictureInPicture: "can-pip",
      pictureInPicture: "pip"
    };
    for (const prop of MEDIA_ATTRIBUTES) {
      $attrs["data-" + (mediaAttrName[prop] ?? camelToKebabCase(prop))] = () => $media[prop];
    }
    host.setAttributes($attrs);
    host.setCSSVars({
      "--media-aspect-ratio": () => {
        const ratio = props.$aspectRatio();
        return ratio ? +ratio.toFixed(4) : null;
      },
      "--media-buffered": () => +$media.bufferedEnd.toFixed(3),
      "--media-current-time": () => +$media.currentTime.toFixed(3),
      "--media-duration": () => Number.isFinite($media.duration) ? +$media.duration.toFixed(3) : 0
    });
    onDispose(() => {
      dispatchEvent(host.el, "destroy");
    });
    return mergeProperties(
      accessors(),
      {
        get user() {
          return controller._request._user;
        },
        get orientation() {
          return controller._request._orientation;
        },
        get provider() {
          return context.$provider();
        },
        get qualities() {
          return context.qualities;
        },
        get audioTracks() {
          return context.audioTracks;
        },
        get textTracks() {
          return context.textTracks;
        },
        get textRenderers() {
          return context.textRenderers;
        },
        get $store() {
          return $media;
        },
        state: new Proxy($media, {
          // @ts-expect-error
          set: noop
        }),
        subscribe: (callback) => scoped(() => effect2(() => callback($media)), scope),
        startLoading: controller._start,
        play: controller._request._play,
        pause: controller._request._pause,
        seekToLiveEdge: controller._request._seekToLiveEdge,
        enterFullscreen: controller._request._enterFullscreen,
        exitFullscreen: controller._request._exitFullscreen,
        enterPictureInPicture: controller._request._enterPictureInPicture,
        exitPictureInPicture: controller._request._exitPictureInPicture
      },
      controller._provider
    );
  }
});

// src/player/media/providers/audio/loader.tsx
var $$_templ2 = /* @__PURE__ */ $$_create_template(`<audio preload="none"></audio>`);
var $$_templ_2 = $$_templ2;
var AudioProviderLoader = class {
  canPlay({ src, type }) {
    return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
  }
  mediaType() {
    return "audio";
  }
  async load() {
    if (!this._audio) {
      throw Error(
        "[vidstack] `<audio>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./chunks/provider-F35T4HJK.js')).AudioProvider(this._audio);
  }
  render($store) {
    const $crossorigin = () => $store.crossorigin, $controls = () => $store.controls;
    return (() => {
      const $$_root = $$_clone($$_templ_2);
      $$_effect(() => $$_attr($$_root, "controls", $controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $crossorigin()));
      $$_ref($$_root, (el) => void (this._audio = el));
      return $$_root;
    })();
  }
};

// src/player/media/providers/video/loader.tsx
var $$_templ3 = /* @__PURE__ */ $$_create_template(`<video preload="none"></video>`);
var $$_templ_22 = $$_templ3;
var VideoProviderLoader = class {
  canPlay(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && canPlayHLSNatively() : src.type === "video/object";
  }
  mediaType() {
    return "video";
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./chunks/provider-IQA4ITJH.js')).VideoProvider(this._video, context);
  }
  render($store) {
    const $controls = () => $store.controls, $crossorigin = () => $store.crossorigin, $poster = () => $store.poster && $store.canLoadPoster === true ? $store.poster : null;
    return (() => {
      const $$_root = $$_clone($$_templ_22);
      $$_effect(() => $$_attr($$_root, "controls", $controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $crossorigin()));
      $$_effect(() => $$_attr($$_root, "poster", $poster()));
      $$_ref($$_root, (el) => void (this._video = el));
      return $$_root;
    })();
  }
};

// src/player/media/providers/hls/loader.tsx
var _HLSProviderLoader = class extends VideoProviderLoader {
  preconnect() {
    preconnect("https://cdn.jsdelivr.net", "preconnect");
  }
  canPlay({ src, type }) {
    return _HLSProviderLoader.supported && isString(src) && (HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type));
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./chunks/provider-75X5GRUH.js')).HLSProvider(this._video, context);
  }
};
var HLSProviderLoader = _HLSProviderLoader;
HLSProviderLoader.supported = isHLSSupported();

// src/player/media/outlet/sources.ts
function useSourceSelection($domSources, $rendered, context) {
  const { $loader, $store: $media, $provider, delegate, $$props } = context;
  const { $src, $preferNativeHLS } = $$props;
  const HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader();
  const $loaders = computed(() => {
    return $preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, HLS_LOADER] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER];
  });
  effect2(() => {
    delegate.dispatch("sources-change", {
      detail: [...normalizeSrc($src()), ...$domSources()]
    });
  });
  effect2(() => {
    const sources = $media.sources, currentSource = peek(() => $media.source);
    let newSource = { src: "", type: "" }, newLoader = null;
    for (const src of sources) {
      const loader = peek($loaders).find((loader2) => loader2.canPlay(src));
      if (loader) {
        newSource = src;
        newLoader = loader;
      }
    }
    if (newSource.src !== currentSource.src || newSource.type !== currentSource.type) {
      delegate.dispatch("source-change", { detail: newSource });
      delegate.dispatch("media-type-change", {
        detail: newLoader?.mediaType(newSource) || "unknown"
      });
    }
    if (newLoader !== peek($loader)) {
      delegate.dispatch("provider-change", { detail: null });
      newLoader && peek(() => newLoader.preconnect?.(context));
      delegate.dispatch("provider-loader-change", { detail: newLoader });
    }
    tick();
  });
  effect2(() => {
    const loader = $loader();
    if (!$rendered() || !loader)
      return;
    peek(() => {
      loader.load(context).then((provider) => {
        if (!peek($rendered))
          return;
        if (peek($loader) === loader) {
          context.delegate.dispatch("provider-change", {
            detail: provider
          });
        }
      });
    });
  });
  effect2(() => {
    const provider = $provider();
    if (!provider)
      return;
    if ($media.canLoad) {
      peek(() => provider.setup({ ...context, player: context.$player() }));
      return;
    }
    peek(() => provider.preconnect?.(context));
  });
  effect2(() => {
    const provider = $provider(), source = $media.source;
    if ($media.canLoad) {
      peek(
        () => provider?.loadSource(
          source,
          peek(() => $media.preload)
        )
      );
      return;
    }
    try {
      isString(source.src) && preconnect(new URL(source.src).origin, "preconnect");
    } catch (e) {
      {
        context.logger?.infoGroup(`Failed to preconnect to source: ${source.src}`).labelledLog("Error", e).dispatch();
      }
    }
  });
}
function normalizeSrc(src) {
  return (isArray(src) ? src : [!isString(src) && "src" in src ? src : { src }]).map(
    ({ src: src2, type }) => ({
      src: src2,
      type: type ?? (!isString(src2) || src2.startsWith("blob:") ? "video/object" : "?")
    })
  );
}

// src/player/media/outlet/tracks.ts
function useTextTracks($domTracks, { textTracks, $$props }) {
  const { $textTracks } = $$props;
  let prevTextTracks = [];
  effect2(() => {
    const newTracks = [...$textTracks(), ...$domTracks()];
    for (const newTrack of newTracks) {
      const id = newTrack.id || TextTrack.createId(newTrack);
      if (!textTracks.getById(id)) {
        newTrack.id = id;
        textTracks.add(newTrack);
      }
    }
    for (const oldTrack of prevTextTracks) {
      if (!newTracks.some((t) => t.id === oldTrack.id)) {
        const track = oldTrack.id && textTracks.getById(oldTrack.id);
        if (track)
          textTracks.remove(track);
      }
    }
    prevTextTracks = newTracks;
  });
}

// src/player/media/outlet/element.ts
var OutletDefinition = defineCustomElement({
  tagName: "media-outlet",
  setup({ host }) {
    const context = useMedia(), $rendered = signal(false), $domSources = signal([]), $domTracks = signal([]);
    onAttach(() => {
      host.el.keepAlive = true;
    });
    onConnect(() => {
      function onMutation() {
        const sources = [], tracks = [], children = host.el.children;
        for (const el of children) {
          if (el instanceof HTMLSourceElement) {
            sources.push({
              src: el.src,
              type: el.type
            });
          } else if (el instanceof HTMLTrackElement) {
            tracks.push({
              id: el.id,
              src: el.src,
              kind: el.track.kind,
              language: el.srclang,
              label: el.label,
              default: el.default,
              type: el.getAttribute("data-type")
            });
          }
        }
        $domSources.set(sources);
        $domTracks.set(tracks);
      }
      onMutation();
      const observer = new MutationObserver(onMutation);
      observer.observe(host.el, { childList: true });
      return () => observer.disconnect();
    });
    useSourceSelection($domSources, $rendered, context);
    useTextTracks($domTracks, context);
    return () => () => {
      const loader = context.$loader();
      if (!loader) {
        $rendered.set(false);
        return;
      }
      $rendered.set(true);
      return loader.render(context.$store);
    };
  }
});

// src/icons/icon.tsx
var $$_templ4 = /* @__PURE__ */ $$_create_template(`<svg viewBox="0 0 32 32" fill="none" aria-hidden="true" focusable="false" data-media-icon="true"></svg>`);
function Icon({ slot, paths: paths2 }) {
  return (() => {
    const $$_root = $$_clone($$_templ4);
    $$_attr($$_root, "slot", slot);
    $$_inner_html($$_root, paths2);
    return $$_root;
  })();
}

// src/utils/dom.ts
function setAttributeIfEmpty(target, name, value) {
  if (!target.hasAttribute(name))
    target.setAttribute(name, value);
}
function setARIALabel(target, label) {
  if (target.hasAttribute("aria-label") || target.hasAttribute("aria-describedby"))
    return;
  function updateAriaDescription() {
    setAttribute(target, "aria-label", label());
  }
  effect2(updateAriaDescription);
}

// src/player/ui/toggle-button/props.ts
var toggleButtonProps = {
  disabled: { initial: false },
  defaultPressed: { initial: false },
  defaultAppearance: { initial: false }
};

// src/player/ui/toggle-button/use-toggle-button.ts
function useToggleButton(host, { $props: { $pressed, $disabled }, ...props }) {
  host.setAttributes({
    disabled: $disabled,
    "data-pressed": $pressed,
    "aria-pressed": () => ariaBool($pressed()),
    "data-media-button": true
  });
  useFocusVisible(host.$el);
  onAttach(() => {
    setAttributeIfEmpty(host.el, "tabindex", "0");
    setAttributeIfEmpty(host.el, "role", "button");
  });
  effect2(() => {
    const target = host.$el();
    if (!target)
      return;
    const clickEvents = ["pointerup", "keydown"];
    for (const eventType of clickEvents)
      listenEvent(target, eventType, onPress);
  });
  function onPress(event) {
    const disabled = $disabled();
    if (disabled || isKeyboardEvent(event) && !isKeyboardClick(event)) {
      if (disabled)
        event.stopImmediatePropagation();
      return;
    }
    event.preventDefault();
    props.onPress?.(event);
  }
  return {
    get pressed() {
      return $pressed();
    },
    get disabled() {
      return $disabled();
    }
  };
}

// src/player/ui/caption-button/element.tsx
var CaptionButtonDefinition = defineCustomElement({
  tagName: "media-caption-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance }, accessors }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => !!$media.textTrack, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "toggleCaptions");
    onAttach(() => {
      setARIALabel(
        host.el,
        () => $media.textTrack ? "Closed-Captions Off" : "Closed-Captions On"
      );
    });
    host.setAttributes({
      "data-hidden": () => $media.textTracks.filter(isTrackCaptionKind).length == 0,
      "default-appearance": $defaultAppearance
    });
    function onPress(event) {
      if ($disabled())
        return;
      remote.toggleCaptions(event);
    }
    return mergeProperties(toggle, accessors(), {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: closed_captions_on_default, slot: "on" }),
          $$_create_component(Icon, { paths: closed_captions_default, slot: "off" })
        ];
      }
    });
  }
});

// src/player/ui/captions/captions-renderer.ts
var CaptionsTextRenderer = class {
  constructor(_renderer) {
    this._renderer = _renderer;
    this.priority = 10;
    this._track = null;
    this._disposal = createDisposalBin();
  }
  attach() {
  }
  canRender() {
    return true;
  }
  detach() {
    this._disposal.empty();
    this._renderer.reset();
    this._track = null;
  }
  changeTrack(track) {
    if (!track || this._track === track)
      return;
    this._disposal.empty();
    if (track.readyState < 2) {
      this._renderer.reset();
      this._disposal.add(
        listenEvent(track, "load", () => this._changeTrack(track), { once: true })
      );
    } else {
      this._changeTrack(track);
    }
    this._disposal.add(
      listenEvent(track, "add-cue", (event) => {
        this._renderer.addCue(event.detail);
      }),
      listenEvent(track, "remove-cue", (event) => {
        this._renderer.removeCue(event.detail);
      })
    );
    this._track = track;
  }
  _changeTrack(track) {
    this._renderer.changeTrack({
      cues: [...track.cues],
      regions: [...track.regions]
    });
  }
};

// src/player/ui/captions/element.tsx
var CaptionsDefinition = defineCustomElement({
  tagName: "media-captions",
  props: { textDir: { initial: "ltr" } },
  setup({ host, props }) {
    onConnect(() => {
      const { $store: $media, textRenderers } = useMedia();
      const renderer = new CaptionsRenderer(host.el), textRenderer = new CaptionsTextRenderer(renderer);
      effect2(() => {
        setAttribute(host.el, "data-hidden", !$media.textTrack);
      });
      function setupAudio() {
        effect2(() => {
          if (!$media.textTrack)
            return;
          listenEvent($media.textTrack, "cue-change", () => {
            host.el.textContent = "";
            const currentTime = peek(() => $media.currentTime);
            for (const cue of $media.textTrack.activeCues) {
              const el = document.createElement("div");
              el.setAttribute("part", "cue");
              el.innerHTML = renderVTTCueString(cue, currentTime);
              host.el.append(el);
            }
          });
          effect2(() => {
            updateTimedVTTCueNodes(host.el, $media.currentTime);
          });
        });
        return () => {
          host.el.textContent = "";
        };
      }
      function setupVideo() {
        effect2(() => {
          renderer.dir = props.$textDir();
        });
        effect2(() => {
          if (!$media.textTrack)
            return;
          renderer.currentTime = $media.currentTime;
        });
        textRenderers.add(textRenderer);
        return () => {
          textRenderer.detach();
          textRenderers.remove(textRenderer);
        };
      }
      effect2(() => {
        if ($media.viewType === "audio") {
          return setupAudio();
        } else {
          return setupVideo();
        }
      });
      return () => {
        textRenderer.detach();
        textRenderers.remove(textRenderer);
        renderer.destroy();
      };
    });
  }
});

// src/player/ui/fullscreen-button/element.tsx
var FullscreenButtonDefinition = defineCustomElement({
  tagName: "media-fullscreen-button",
  props: {
    ...toggleButtonProps,
    target: { initial: "prefer-media" }
  },
  setup({ host, props: { $target, $disabled, $defaultAppearance }, accessors }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => $media.fullscreen, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "toggleFullscreen");
    onAttach(() => {
      setARIALabel(host.el, () => $media.fullscreen ? "Exit Fullscreen" : "Enter Fullscreen");
    });
    host.setAttributes({
      "data-hidden": () => !$media.canFullscreen,
      "data-fullscreen": () => $media.fullscreen,
      "default-appearance": $defaultAppearance
    });
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.exitFullscreen($target(), event) : remote.enterFullscreen($target(), event);
    }
    return mergeProperties(toggle, accessors(), {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: fullscreen_default, slot: "enter" }),
          $$_create_component(Icon, { paths: fullscreen_exit_default, slot: "exit" })
        ];
      }
    });
  }
});

// src/player/ui/live-indicator/element.tsx
var $$_templ5 = /* @__PURE__ */ $$_create_template(`<div part="container"><div part="text">LIVE</div></div>`);
var LiveIndicatorDefinition = defineCustomElement({
  tagName: "media-live-indicator",
  setup({ host }) {
    const { $store: $media, remote } = useMedia();
    useFocusVisible(host.$el);
    host.setAttributes({
      tabindex: () => $media.live ? 0 : null,
      role: () => $media.live ? "button" : null,
      "data-live": () => $media.live,
      "data-live-edge": () => $media.liveEdge,
      "data-media-button": true
    });
    onAttach(() => {
      setARIALabel(host.el, () => $media.live ? "Go live" : null);
      const clickEvents = ["pointerup", "keydown"];
      for (const eventType of clickEvents)
        listenEvent(host.el, eventType, onPress);
    });
    function onPress(event) {
      if ($media.liveEdge || isKeyboardEvent(event) && !isKeyboardClick(event))
        return;
      remote.seekToLiveEdge(event);
    }
    return () => $$_clone($$_templ5);
  }
});

// src/player/ui/mute-button/element.tsx
var MuteButtonDefinition = defineCustomElement({
  tagName: "media-mute-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia(), $pressed = computed(() => $media.muted || $media.volume === 0), toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "toggleMuted");
    onAttach(() => {
      setARIALabel(host.el, () => $pressed() ? "Unmute" : "Mute");
    });
    host.setAttributes({
      "data-muted": $pressed,
      "data-volume": getVolumeText,
      "default-appearance": $defaultAppearance
    });
    function getVolumeText() {
      if ($media.muted || $media.volume === 0)
        return "muted";
      else if ($media.volume >= 0.5)
        return "high";
      else if ($media.volume < 0.5)
        return "low";
    }
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.unmute(event) : remote.mute(event);
    }
    return mergeProperties(toggle, {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: volume_high_default, slot: "volume-high" }),
          $$_create_component(Icon, { paths: volume_low_default, slot: "volume-low" }),
          $$_create_component(Icon, { paths: mute_default, slot: "volume-muted" })
        ];
      }
    });
  }
});

// src/player/ui/pip-button/element.tsx
var PIPButtonDefinition = defineCustomElement({
  tagName: "media-pip-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance }, accessors }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => $media.pictureInPicture, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "togglePictureInPicture");
    onAttach(() => {
      setARIALabel(
        host.el,
        () => $media.pictureInPicture ? "Exit Picture In Picture" : "Enter Picture In Picture"
      );
    });
    host.setAttributes({
      "data-hidden": () => !$media.canPictureInPicture,
      "data-pip": () => $media.pictureInPicture,
      "default-appearance": $defaultAppearance
    });
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.exitPictureInPicture(event) : remote.enterPictureInPicture(event);
    }
    return mergeProperties(toggle, accessors(), {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: picture_in_picture_default, slot: "enter" }),
          $$_create_component(Icon, { paths: picture_in_picture_exit_default, slot: "exit" })
        ];
      }
    });
  }
});

// src/player/ui/play-button/element.tsx
var PlayButtonDefinition = defineCustomElement({
  tagName: "media-play-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => !$media.paused, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "togglePaused");
    onAttach(() => {
      setARIALabel(host.el, () => $media.paused ? "Play" : "Pause");
    });
    host.setAttributes({
      "default-appearance": $defaultAppearance,
      "data-paused": () => $media.paused,
      "data-ended": () => $media.ended
    });
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.pause(event) : remote.play(event);
    }
    return mergeProperties(toggle, {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: play_default, slot: "play" }),
          $$_create_component(Icon, { paths: replay_default, slot: "replay" }),
          $$_create_component(Icon, { paths: pause_default, slot: "pause" })
        ];
      }
    });
  }
});

// src/player/ui/poster/props.ts
var posterProps = {
  alt: {}
};

// src/player/ui/poster/element.tsx
var $$_templ6 = /* @__PURE__ */ $$_create_template(`<img part="img" />`);
var PosterDefinition = defineCustomElement({
  tagName: "media-poster",
  props: posterProps,
  setup({ host, props: { $alt } }) {
    const { $store: $media } = useMedia(), remote = new MediaRemoteControl();
    const $crossorigin = () => $media.crossorigin, $imgSrc = () => $media.canLoad && $media.poster.length ? $media.poster : null, $imgAlt = () => $imgSrc() ? $alt() : null, $imgLoading = signal(true), $imgError = signal(false);
    host.setAttributes({
      "data-loading": $imgLoading,
      "data-hidden": $imgError
    });
    onConnect(() => {
      window.requestAnimationFrame(() => {
        if (!$media.canLoad)
          preconnect($media.poster);
      });
      remote.setTarget(host.el);
      remote.hidePoster();
      return () => remote.showPoster();
    });
    effect2(() => {
      const isLoading = $media.canLoad && !!$media.poster;
      $imgLoading.set(isLoading);
      $imgError.set(false);
    });
    function onLoad() {
      $imgLoading.set(false);
    }
    function onError() {
      $imgLoading.set(false);
      $imgError.set(true);
    }
    return () => (() => {
      const $$_root = $$_clone($$_templ6);
      $$_effect(() => $$_attr($$_root, "src", $imgSrc()));
      $$_effect(() => $$_attr($$_root, "alt", $imgAlt()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $crossorigin()));
      $$_listen($$_root, "load", onLoad);
      $$_listen($$_root, "error", onError);
      return $$_root;
    })();
  }
});

// src/player/ui/seek-button/element.tsx
var SeekButtonDefinition = defineCustomElement({
  tagName: "media-seek-button",
  props: { seconds: { initial: 30 }, defaultAppearance: { initial: false } },
  setup({ host, props: { $seconds, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia();
    useFocusVisible(host.$el);
    onAttach(() => {
      setAttributeIfEmpty(host.el, "tabindex", "0");
      setAttributeIfEmpty(host.el, "role", "button");
      setARIALabel(
        host.el,
        () => `Seek ${$seconds() > 0 ? "forward" : "backward"} ${$seconds()} seconds`
      );
      const clickEvents = ["pointerup", "keydown"];
      for (const eventType of clickEvents)
        listenEvent(host.el, eventType, onPress);
    });
    host.setAttributes({
      seconds: $seconds,
      "data-media-button": true,
      "default-appearance": $defaultAppearance,
      "data-hidden": () => !$media.canSeek
    });
    function onPress(event) {
      if (isKeyboardEvent(event) && !isKeyboardClick(event))
        return;
      remote.seek($media.currentTime + $seconds(), event);
    }
    return () => [
      $$_create_component(Icon, { paths: seek_backward_default, slot: "backward" }),
      $$_create_component(Icon, { paths: seek_forward_default, slot: "forward" })
    ];
  }
});

// src/player/ui/slider/store.ts
var sliderStore = createStore({
  min: 0,
  max: 100,
  value: 50,
  pointerValue: 0,
  focused: false,
  dragging: false,
  pointing: false,
  get interactive() {
    return this.dragging || this.focused || this.pointing;
  },
  get fillRate() {
    return calcRate(this.min, this.max, this.value);
  },
  get fillPercent() {
    return this.fillRate * 100;
  },
  get pointerRate() {
    return calcRate(this.min, this.max, this.pointerValue);
  },
  get pointerPercent() {
    return this.pointerRate * 100;
  }
});
function calcRate(min, max, value) {
  const range = max - min, offset = value - min;
  return range > 0 ? offset / range : 0;
}
var sliderStoreContext = createContext(() => sliderStore.create());
function useSliderStore() {
  return useContext(sliderStoreContext);
}

// src/player/ui/slider-thumbnail/element.tsx
var $$_templ7 = /* @__PURE__ */ $$_create_template(`<div part="container"><img part="img" loading="eager" decoding="async" /></div>`);
var SliderThumbnailDefinition = defineCustomElement({
  tagName: "media-slider-thumbnail",
  props: { src: { initial: "" } },
  setup({ host, props: { $src } }) {
    const $img = signal(null), $imgSrc = signal(""), $imgLoaded = signal(false), $error = signal(false), $coords = signal(null), $cueList = signal(null), $activeCue = signal(null), $hidden = () => $error() || !Number.isFinite($media.duration), $slider = useSliderStore(), { $store: $media } = useMedia(), $crossorigin = () => $media.crossorigin;
    host.setAttributes({
      "data-loading": () => !$hidden() && !$imgLoaded(),
      "data-hidden": $hidden
    });
    effect2(() => {
      if (!$media.canLoad)
        return;
      const video = document.createElement("video");
      video.crossOrigin = "";
      const track = document.createElement("track");
      track.src = $src();
      track.default = true;
      track.kind = "metadata";
      video.append(track);
      let cancelled = false;
      $error.set(false);
      $imgLoaded.set(false);
      track.onload = () => {
        if (cancelled)
          return;
        $cueList.set(track.track.cues);
      };
      track.onerror = () => $error.set(true);
      return () => {
        cancelled = true;
        $cueList.set(null);
      };
    });
    effect2(() => {
      const cues = $cueList();
      if (!cues || !Number.isFinite($media.duration)) {
        $activeCue.set(null);
        return;
      }
      const currentTime = $slider.pointerRate * $media.duration;
      for (let i = 0; i < cues.length; i++) {
        if (currentTime >= cues[i].startTime && currentTime <= cues[i].endTime) {
          $activeCue.set(cues[i]);
          break;
        }
      }
    });
    effect2(() => {
      const cue = $activeCue();
      if (!cue) {
        $imgSrc.set("");
        $coords.set(null);
        return;
      }
      const [_src, _coords] = (cue.text || "").split("#");
      const [_props, _values] = _coords.split("=");
      $imgSrc.set(
        !peek($src).startsWith("/") && !/https?:/.test(_src) ? `${new URL(peek($src)).origin}${_src.replace(/^\/?/, "/")}` : _src
      );
      if (_props && _values) {
        const coords = {}, values = _values.split(",");
        for (let i = 0; i < _props.length; i++)
          coords[_props[i]] = +values[i];
        $coords.set(coords);
      } else {
        $coords.set(null);
      }
    });
    effect2(() => {
      $imgSrc();
      $imgLoaded.set(false);
    });
    const styleReverts = [];
    function applyStyle(el, name, value, priority) {
      el.style.setProperty(name, value, priority);
      styleReverts.push(() => el.style.removeProperty(name));
    }
    effect2(() => {
      const img = $img(), coords = $coords();
      if (!img || !coords || !$imgLoaded()) {
        for (const revert of styleReverts)
          revert();
        return;
      }
      const { w, h: h2, x, y } = coords, { maxWidth, maxHeight, minWidth, minHeight } = getComputedStyle(host.el), minRatio = Math.max(parseInt(minWidth) / w, parseInt(minHeight) / h2), maxRatio = Math.min(parseInt(maxWidth) / w, parseInt(maxHeight) / h2), scale = maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
      styleReverts.length = 0;
      applyStyle(host.el, "--thumbnail-width", `${w * scale}px`);
      applyStyle(host.el, "--thumbnail-height", `${h2 * scale}px`);
      applyStyle(img, "width", `${img.naturalWidth * scale}px`);
      applyStyle(img, "height", `${img.naturalHeight * scale}px`);
      applyStyle(img, "transform", `translate(-${x * scale}px, -${y * scale}px)`);
    });
    return () => (() => {
      const $$_root = $$_clone($$_templ7), $$_el = $$_root.firstChild;
      $$_effect(() => $$_attr($$_el, "src", $imgSrc()));
      $$_effect(() => $$_attr($$_el, "crossorigin", $crossorigin()));
      $$_listen($$_el, "load", () => $imgLoaded.set(true));
      $$_ref($$_el, $img.set);
      return $$_root;
    })();
  }
});

// src/utils/time.ts
function padNumberWithZeroes(num, expectedLength) {
  const str = String(num);
  const actualLength = str.length;
  const shouldPad = actualLength < expectedLength;
  if (shouldPad) {
    const padLength = expectedLength - actualLength;
    const padding = `0`.repeat(padLength);
    return `${padding}${num}`;
  }
  return str;
}
function parseTime(duration) {
  const hours = Math.trunc(duration / 3600);
  const minutes = Math.trunc(duration % 3600 / 60);
  const seconds = Math.trunc(duration % 60);
  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
  return {
    hours,
    minutes,
    seconds,
    fraction
  };
}
function formatTime(duration, shouldPadHours = false, shouldPadMinutes = false, shouldAlwaysShowHours = false) {
  const { hours, minutes, seconds } = parseTime(duration);
  const paddedHours = shouldPadHours ? padNumberWithZeroes(hours, 2) : hours;
  const paddedMinutes = shouldPadMinutes ? padNumberWithZeroes(minutes, 2) : minutes;
  const paddedSeconds = padNumberWithZeroes(seconds, 2);
  if (hours > 0 || shouldAlwaysShowHours) {
    return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
  }
  return `${paddedMinutes}:${paddedSeconds}`;
}
function formatSpokenTime(duration) {
  const spokenParts = [];
  const { hours, minutes, seconds } = parseTime(duration);
  const pluralize = (num, word) => num === 1 ? word : `${word}s`;
  if (hours > 0) {
    spokenParts.push(`${hours} ${pluralize(hours, "hour")}`);
  }
  if (minutes > 0) {
    spokenParts.push(`${minutes} ${pluralize(minutes, "minute")}`);
  }
  if (seconds > 0 || spokenParts.length === 0) {
    spokenParts.push(`${seconds} ${pluralize(seconds, "second")}`);
  }
  return spokenParts.join(", ");
}

// src/player/ui/slider/format.ts
var sliderValueFormattersContext = createContext(() => ({}));

// src/player/ui/slider-value/props.ts
var sliderValueTextProps = {
  type: { initial: "current" },
  format: {},
  showHours: { initial: false },
  padHours: { initial: false },
  padMinutes: { initial: false },
  decimalPlaces: { initial: 2 }
};

// src/player/ui/slider-value/element.tsx
var $$_templ8 = /* @__PURE__ */ $$_create_template(`<span></span>`);
var SliderValueDefinition = defineCustomElement({
  tagName: "media-slider-value",
  props: sliderValueTextProps,
  setup({ props: { $type, $format, $decimalPlaces, $padHours, $padMinutes, $showHours } }) {
    const $slider = useSliderStore(), formatters = useContext(sliderValueFormattersContext);
    const $text = computed(() => {
      const value = $type() === "current" ? $slider.value : $slider.pointerValue;
      const format = $format();
      if (format === "percent") {
        const range = $slider.max - $slider.min;
        const percent = value / range * 100;
        return (formatters.percent ?? round)(percent, $decimalPlaces()) + "\uFE6A";
      } else if (format === "time") {
        return (formatters.time ?? formatTime)(value, $padHours(), $padMinutes(), $showHours());
      } else {
        return formatters.value?.(value) ?? value.toFixed(2);
      }
    });
    return () => (() => {
      const $$_root = $$_clone($$_templ8);
      $$_insert_lite($$_root, $text);
      return $$_root;
    })();
  }
});

// src/player/ui/slider-video/props.ts
var sliderVideoProps = {
  src: {}
};

// src/player/ui/slider-video/element.tsx
var $$_templ9 = /* @__PURE__ */ $$_create_template(`<video muted="" playsinline="" preload="auto" part="video" style="max-width: unset"></video>`);
var SliderVideoDefinition = defineCustomElement({
  tagName: "media-slider-video",
  props: sliderVideoProps,
  setup({ host, props: { $src } }) {
    let videoElement = null;
    const $canPlay = signal(false), $error = signal(false), $slider = useSliderStore(), { $store: $media } = useMedia(), $crossorigin = () => $media.crossorigin, $videoSrc = () => $media.canPlay ? $src() : null, $hidden = () => !!$error() || !$media.canPlay || !Number.isFinite($media.duration);
    host.setAttributes({
      "data-loading": () => !$canPlay() && !$hidden(),
      "data-hidden": $hidden
    });
    effect2(() => {
      if ($canPlay() && videoElement && Number.isFinite($media.duration) && Number.isFinite($slider.pointerRate)) {
        videoElement.currentTime = $slider.pointerRate * $media.duration;
      }
    });
    effect2(() => {
      $src();
      $canPlay.set(false);
      $error.set(false);
    });
    onConnect(() => {
      if (videoElement.readyState >= 2)
        onCanPlay();
    });
    function onCanPlay(trigger) {
      $canPlay.set(true);
      dispatchEvent(host.el, "can-play", { trigger });
    }
    function onError(trigger) {
      $error.set(true);
      dispatchEvent(host.el, "error", { trigger });
    }
    return () => (() => {
      const $$_root = $$_clone($$_templ9);
      $$_effect(() => $$_attr($$_root, "src", $videoSrc()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $crossorigin()));
      $$_listen($$_root, "canplay", onCanPlay);
      $$_listen($$_root, "error", onError);
      $$_ref($$_root, (el) => void (videoElement = el));
      return $$_root;
    })();
  }
});

// src/player/ui/slider/utils.ts
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1);
  const range = max - min;
  const fill = range * boundRate;
  const stepRatio = Math.round(fill / step);
  const steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/slider/use-events.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
function useSliderEvents(host, { $disabled, $step, $keyStep, $shiftKeyMultiplier }, { onValueChange, onDragStart, onDragValueChange, onDragEnd }, $store) {
  const remote = useMedia().remote;
  effect2(() => {
    const target = host.$el();
    if (!target || $disabled())
      return;
    listenEvent(target, "focus", onFocus);
    listenEvent(target, "pointerenter", onPointerEnter);
    listenEvent(target, "pointermove", onPointerMove);
    listenEvent(target, "pointerleave", onPointerLeave);
    listenEvent(target, "pointerdown", onPointerDown);
    listenEvent(target, "keydown", onKeyDown);
    listenEvent(target, "keyup", onKeyUp);
  });
  effect2(() => {
    if ($disabled() || !$store.dragging)
      return;
    listenEvent(document, "pointerup", onDocumentPointerUp);
    listenEvent(document, "pointermove", onDocumentPointerMove);
    if (IS_SAFARI)
      listenEvent(document, "touchmove", onDocumentTouchMove, { passive: false });
  });
  function onFocus() {
    updatePointerValue($store.value);
  }
  function updateValue(value, trigger) {
    $store.value = Math.max($store.min, Math.min(value, $store.max));
    const event = createEvent(host.el, "value-change", { detail: $store.value, trigger });
    host.el?.dispatchEvent(event);
    onValueChange?.(event);
    if ($store.dragging) {
      const event2 = createEvent(host.el, "drag-value-change", { detail: value, trigger });
      host.el?.dispatchEvent(event2);
      onDragValueChange?.(event2);
    }
  }
  function updatePointerValue(value, trigger) {
    $store.pointerValue = Math.max($store.min, Math.min(value, $store.max));
    dispatchEvent(host.el, "pointer-value-change", { detail: value, trigger });
    if ($store.dragging)
      updateValue(value, trigger);
  }
  function getPointerValue(event) {
    const thumbClientX = event.clientX;
    const { left: trackLeft, width: trackWidth } = host.el.getBoundingClientRect();
    const thumbPositionRate = (thumbClientX - trackLeft) / trackWidth;
    return getValueFromRate($store.min, $store.max, thumbPositionRate, $step());
  }
  function onPointerEnter() {
    $store.pointing = true;
  }
  function onPointerMove(event) {
    if ($store.dragging)
      return;
    updatePointerValue(getPointerValue(event), event);
  }
  function onPointerLeave(event) {
    $store.pointing = false;
  }
  function onPointerDown(event) {
    const value = getPointerValue(event);
    onStartDragging(value, event);
    updatePointerValue(value, event);
  }
  function onStartDragging(value, trigger) {
    if ($store.dragging)
      return;
    $store.dragging = true;
    const dragStartEvent = createEvent(host.el, "drag-start", { detail: value, trigger });
    host.el?.dispatchEvent(dragStartEvent);
    onDragStart?.(dragStartEvent);
  }
  function onStopDragging(value, trigger) {
    if (!$store.dragging)
      return;
    $store.dragging = false;
    remote.resumeUserIdle(trigger);
    const dragEndEvent = createEvent(host.el, "drag-start", { detail: value, trigger });
    host.el?.dispatchEvent(dragEndEvent);
    onDragEnd?.(dragEndEvent);
  }
  let lastDownKey;
  function onKeyDown(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key: key2 } = event;
    if (key2 === "Home" || key2 === "PageUp") {
      updatePointerValue($store.min, event);
      updateValue($store.min, event);
      return;
    } else if (key2 === "End" || key2 === "PageDown") {
      updatePointerValue($store.max, event);
      updateValue($store.max, event);
      return;
    } else if (/[0-9]/.test(key2)) {
      const value2 = ($store.max - $store.min) / 10 * Number(key2);
      updatePointerValue(value2, event);
      updateValue(value2, event);
      return;
    }
    const value = getKeyValue(event);
    if (!value)
      return;
    const repeat = key2 === lastDownKey;
    if (!$store.dragging && repeat)
      onStartDragging(value, event);
    updatePointerValue(value, event);
    if (!repeat)
      updateValue(value, event);
    lastDownKey = key2;
  }
  function onKeyUp(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    lastDownKey = "";
    if (!$store.dragging)
      return;
    const value = getKeyValue(event) ?? $store.value;
    updatePointerValue(value);
    onStopDragging(value, event);
  }
  function getKeyValue(event) {
    const { key: key2, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key2);
    if (!isValidKey)
      return;
    const modifiedStep = !shiftKey ? $keyStep() : $keyStep() * $shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key2]), diff = modifiedStep * direction, steps = ($store.value + diff) / $step();
    return Number(($step() * steps).toFixed(3));
  }
  function onDocumentPointerUp(event) {
    const value = getPointerValue(event);
    updatePointerValue(value, event);
    onStopDragging(value, event);
  }
  function onDocumentTouchMove(event) {
    event.preventDefault();
  }
  function onDocumentPointerMove(event) {
    updatePointerValue(getPointerValue(event), event);
  }
}

// src/player/ui/slider/create.tsx
var $$_templ10 = /* @__PURE__ */ $$_create_template(`<div part="track"></div>`);
var $$_templ_23 = /* @__PURE__ */ $$_create_template(`<div part="track track-fill"></div>`);
var $$_templ_3 = /* @__PURE__ */ $$_create_template(`<div part="track track-progress"></div>`);
var $$_templ_4 = /* @__PURE__ */ $$_create_template(`<div part="thumb-container"><div part="thumb"></div></div>`);
function createSlider(host, { $props, readonly, aria, ...callbacks }, accessors) {
  provideContext(sliderStoreContext);
  provideContext(sliderValueFormattersContext);
  const scope = getScope(), $store = useContext(sliderStoreContext), $focused = useFocusVisible(host.$el), { $disabled, $min, $max, $value, $step } = $props;
  host.setAttributes({
    disabled: $disabled,
    "data-dragging": () => $store.dragging,
    "data-pointing": () => $store.pointing,
    "data-interactive": () => $store.interactive,
    "aria-disabled": () => ariaBool($disabled()),
    "aria-valuemin": aria?.valueMin ?? (() => $store.min),
    "aria-valuemax": aria?.valueMax ?? (() => $store.max),
    "aria-valuenow": aria?.valueNow ?? (() => Math.round($store.value)),
    "aria-valuetext": aria?.valueText ?? (() => round($store.value / $store.max * 100, 2) + "%"),
    "data-media-slider": true
  });
  host.setCSSVars({
    "--slider-fill-rate": () => $store.fillRate,
    "--slider-fill-value": () => $store.value,
    "--slider-fill-percent": () => $store.fillPercent + "%",
    "--slider-pointer-rate": () => $store.pointerRate,
    "--slider-pointer-value": () => $store.pointerValue,
    "--slider-pointer-percent": () => $store.pointerPercent + "%"
  });
  useSliderEvents(host, $props, callbacks, $store);
  onAttach(() => {
    setAttributeIfEmpty(host.el, "role", "slider");
    setAttributeIfEmpty(host.el, "tabindex", "0");
    setAttributeIfEmpty(host.el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(host.el, "autocomplete", "off");
  });
  effect2(() => {
    $store.focused = $focused();
  });
  effect2(() => {
    const target = host.$el();
    if (!target || $disabled())
      return;
    const preview = target.querySelector('[slot="preview"]');
    if (!preview)
      return;
    const rect = preview.getBoundingClientRect();
    const styles = {
      "--computed-width": rect.width + "px",
      "--computed-height": rect.height + "px",
      "--preview-top": "calc(-1 * var(--media-slider-preview-gap, calc(var(--preview-height) - 2px)))",
      "--preview-width": "var(--media-slider-preview-width, var(--computed-width))",
      "--preview-height": "var(--media-slider-preview-height, var(--computed-height))",
      "--preview-width-half": "calc(var(--preview-width) / 2)",
      "--preview-left-clamp": "max(var(--preview-width-half), var(--slider-pointer-percent))",
      "--preview-right-clamp": "calc(100% - var(--preview-width-half))",
      "--preview-left": "min(var(--preview-left-clamp), var(--preview-right-clamp))"
    };
    for (const name of Object.keys(styles)) {
      setStyle(preview, name, styles[name]);
    }
    function onPreviewResize() {
      const rect2 = preview.getBoundingClientRect();
      setStyle(preview, "--computed-width", rect2.width + "px");
      setStyle(preview, "--computed-height", rect2.height + "px");
    }
    window.requestAnimationFrame(onPreviewResize);
    const observer = new ResizeObserver(onPreviewResize);
    observer.observe(preview);
    return () => observer.disconnect();
  });
  if (!readonly) {
    effect2(() => {
      $store.min = $min();
      $store.max = $max();
    });
    effect2(() => {
      if (peek(() => $store.dragging))
        return;
      $store.value = getClampedValue($store.min, $store.max, $value(), $step());
    });
  }
  effect2(() => {
    if (!$disabled())
      return;
    $store.dragging = false;
    $store.pointing = false;
  });
  return {
    $store,
    members: mergeProperties(
      accessors(),
      {
        get value() {
          return $store.value;
        },
        set value(value) {
          $store.value = value;
        },
        get $store() {
          return $store;
        },
        state: new Proxy($store, {
          // @ts-expect-error
          set: noop
        }),
        subscribe: (callback) => scoped(() => effect2(() => callback($store)), scope),
        $render: () => {
          return [$$_clone($$_templ10), $$_clone($$_templ_23), $$_clone($$_templ_3), $$_clone($$_templ_4)];
        }
      },
      {}
    )
  };
}

// src/player/ui/slider/props.ts
var sliderProps = {
  min: { initial: 0 },
  max: { initial: 100 },
  disabled: { initial: false, type: { from: false } },
  value: { initial: 100 },
  step: { initial: 1 },
  keyStep: { initial: 1 },
  shiftKeyMultiplier: { initial: 5 }
};

// src/player/ui/slider/element.ts
var SliderDefinition = defineCustomElement({
  tagName: "media-slider",
  props: sliderProps,
  setup({ host, props, accessors }) {
    const { members } = createSlider(host, { $props: props }, accessors);
    return members;
  }
});

// src/player/ui/time-slider/props.ts
var timeSliderProps = {
  ...sliderProps,
  min: { initial: 0, attribute: false },
  max: { initial: 0, attribute: false },
  value: { initial: 0, attribute: false },
  pauseWhileDragging: { initial: false },
  seekingRequestThrottle: { initial: 100 }
};

// src/player/ui/time-slider/element.tsx
var TimeSliderDefinition = defineCustomElement({
  tagName: "media-time-slider",
  props: timeSliderProps,
  setup({
    host,
    props: { $pauseWhileDragging, $seekingRequestThrottle, $disabled, ...props },
    accessors
  }) {
    const { $store: $media, remote } = useMedia(), { $store, members } = createSlider(
      host,
      {
        $props: {
          ...props,
          $step: () => props.$step() / $media.duration * 100,
          $keyStep: () => props.$keyStep() / $media.duration * 100,
          $disabled: () => $disabled() || !$media.canSeek
        },
        readonly: true,
        aria: { valueMin: 0, valueMax: 100, valueText: getSpokenText },
        onDragStart,
        onDragEnd,
        onValueChange,
        onDragValueChange
      },
      accessors
    );
    onAttach(() => {
      setAttributeIfEmpty(host.el, "aria-label", "Media time");
    });
    effect2(() => {
      const newValue = getPercent($media.currentTime);
      if (!peek(() => $store.dragging)) {
        $store.value = newValue;
        dispatchEvent(host.el, "value-change", { detail: newValue });
      }
    });
    let dispatchSeeking;
    effect2(() => {
      dispatchSeeking = functionThrottle(seeking, $seekingRequestThrottle());
    });
    function seeking(time, event) {
      remote.seeking(time, event);
    }
    function seek(time, percent, event) {
      dispatchSeeking.cancel();
      if ($media.live && percent >= 99) {
        remote.seekToLiveEdge(event);
        return;
      }
      remote.seek(time, event);
    }
    let wasPlayingBeforeDragStart = false;
    function onDragStart(event) {
      if ($pauseWhileDragging()) {
        wasPlayingBeforeDragStart = !$media.paused;
        remote.pause(event);
      }
    }
    function onValueChange(event) {
      if ($store.dragging || !event.trigger)
        return;
      onDragEnd(event);
    }
    function onDragValueChange(event) {
      dispatchSeeking(getTime(event.detail), event);
    }
    function onDragEnd(event) {
      const percent = event.detail;
      seek(getTime(percent), percent, event);
      if ($pauseWhileDragging() && wasPlayingBeforeDragStart) {
        remote.play(event);
        wasPlayingBeforeDragStart = false;
      }
    }
    function getTime(percent) {
      return Math.round(percent / 100 * $media.duration);
    }
    function getPercent(time) {
      const rate = Math.max(
        0,
        Math.min(1, $media.liveEdge ? 1 : Math.min(time, $media.duration) / $media.duration)
      );
      return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
    }
    function getSpokenText() {
      const time = getTime($store.value);
      return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime($media.duration)}` : "live";
    }
    provideContext(sliderValueFormattersContext, {
      value(percent) {
        const time = getTime(percent);
        return Number.isFinite(time) ? ($media.live ? time - $media.duration : time).toFixed(0) : "LIVE";
      },
      time(percent, padHours, padMinutes, showHours) {
        const time = getTime(percent);
        const value = $media.live ? time - $media.duration : time;
        return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), padHours, padMinutes, showHours)}` : "LIVE";
      }
    });
    return mergeProperties(members, {
      // redeclare the following properties to ensure they're read-only.
      get min() {
        return members.min;
      },
      get max() {
        return members.max;
      },
      get value() {
        return members.value;
      }
    });
  }
});

// src/player/ui/time/props.ts
var timeProps = {
  type: { initial: "current" },
  showHours: { initial: false },
  padHours: { initial: false },
  padMinutes: { initial: false },
  remainder: { initial: false }
};

// src/player/ui/time/element.tsx
var $$_templ11 = /* @__PURE__ */ $$_create_template(`<span></span>`);
var TimeDefinition = defineCustomElement({
  tagName: "media-time",
  props: timeProps,
  setup({ props: { $remainder, $padHours, $padMinutes, $showHours, $type } }) {
    const $media = useMedia().$store;
    const $formattedTime = computed(() => {
      const seconds = getSeconds($type(), $media), duration = $media.duration;
      if (!Number.isFinite(seconds + duration))
        return "LIVE";
      const time = $remainder() ? Math.max(0, duration - seconds) : seconds;
      return formatTime(time, $padHours(), $padMinutes(), $showHours());
    });
    return () => (() => {
      const $$_root = $$_clone($$_templ11);
      $$_insert_lite($$_root, $formattedTime);
      return $$_root;
    })();
  }
});
function getSeconds(type, $media) {
  switch (type) {
    case "buffered":
      return $media.bufferedEnd;
    case "duration":
      return $media.duration;
    default:
      return $media.currentTime;
  }
}

// src/player/ui/toggle-button/element.ts
var ToggleButtonDefinition = defineCustomElement({
  tagName: "media-toggle-button",
  props: toggleButtonProps,
  setup({ host, props }) {
    const $pressed = signal(props.$defaultPressed()), toggle = useToggleButton(host, {
      $props: { ...props, $pressed },
      onPress
    });
    function onPress() {
      if (props.$disabled())
        return;
      $pressed.set((p) => !p);
    }
    return toggle;
  }
});

// src/player/ui/volume-slider/props.ts
var volumeSliderProps = {
  ...sliderProps,
  min: { initial: 0, attribute: false },
  max: { initial: 100, attribute: false },
  value: { initial: 100, attribute: false }
};

// src/player/ui/volume-slider/element.tsx
var VolumeSliderDefinition = defineCustomElement({
  tagName: "media-volume-slider",
  props: volumeSliderProps,
  setup({ host, props, accessors }) {
    const { $store: $media, remote } = useMedia(), { $store, members } = createSlider(
      host,
      {
        $props: props,
        readonly: true,
        aria: { valueMin: 0, valueMax: 100 },
        onValueChange: functionThrottle(onVolumeChange, 25)
      },
      accessors
    );
    onAttach(() => {
      setAttributeIfEmpty(host.el, "aria-label", "Media volume");
    });
    effect2(() => {
      const newValue = $media.muted ? 0 : $media.volume * 100;
      $store.value = newValue;
      dispatchEvent(host.el, "value-change", { detail: newValue });
    });
    function onVolumeChange(event) {
      if (!event.trigger)
        return;
      const mediaVolume = round(event.detail / 100, 3);
      remote.changeVolume(mediaVolume, event);
    }
    return mergeProperties(members, {
      // redeclare the following properties to ensure they're read-only.
      get min() {
        return members.min;
      },
      get max() {
        return members.max;
      },
      get value() {
        return members.value;
      }
    });
  }
});

// src/register.ts
function registerAllElements() {
  [
    PlayerDefinition,
    OutletDefinition,
    PosterDefinition,
    MediaIconDefinition,
    PlayButtonDefinition,
    MuteButtonDefinition,
    PIPButtonDefinition,
    FullscreenButtonDefinition,
    CaptionButtonDefinition,
    SeekButtonDefinition,
    SliderDefinition,
    SliderThumbnailDefinition,
    SliderValueDefinition,
    SliderVideoDefinition,
    TimeDefinition,
    TimeSliderDefinition,
    ToggleButtonDefinition,
    VolumeSliderDefinition,
    LiveIndicatorDefinition,
    CaptionsDefinition
  ].map(registerLiteCustomElement);
}

// src/cdn.ts
registerAllElements();
/*! Bundled license information:

maverick.js/dist/dev/chunks/chunk-SLYTIALI.js:
  (**
   * The code below this comment was adapted from Lit: https://github.dev/lit/lit
   *
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
